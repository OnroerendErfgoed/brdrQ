# -*- coding: utf-8 -*-
"""
/***************************************************************************
 brdrQDockWidget
                                 A QGIS plugin
 aligns thematic polygons to reference polygons
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-10-08
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Karel Dieussaert
        email                : karel.dieussaert@geosolutions.be
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from PyQt5.QtWidgets import QListWidgetItem
from brdr.aligner import Aligner
from brdr.constants import PREDICTION_SCORE, EVALUATION_FIELD_NAME
from brdr.enums import AlignerResultType, GRBType
from brdr.geometry_utils import geom_from_wkt
from brdr.grb import GRBActualLoader, GRBFiscalParcelLoader
from brdr.loader import DictLoader
from brdr.utils import diffs_from_dict_processresults
from qgis import processing
from qgis.PyQt import QtWidgets, uic
from qgis.PyQt.QtCore import Qt
from qgis.PyQt.QtCore import pyqtSignal
from qgis.core import QgsMapLayerProxyModel
from qgis.core import QgsStyle
from qgis.gui import QgsMapToolPan
from qgis.utils import OverrideCursor

from .brdrq_dockwidget_aligner import brdrQDockWidgetAligner
from .brdrq_utils import SelectTool, zoom_to_feature, geojson_to_layer, GRB_TYPES, \
    ADPF_VERSIONS, geom_qgis_to_shapely, remove_group_layer

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'brdrq_dockwidget_featurealigner.ui'))


class brdrQDockWidgetFeatureAligner(QtWidgets.QDockWidget, FORM_CLASS,brdrQDockWidgetAligner):
    closingPlugin = pyqtSignal()

    def __init__(self,brdrqplugin, parent=None):
        """Constructor."""
        print ("init brdrQDockWidgetFeatureAligner")
        brdrQDockWidgetAligner.__init__(self,brdrqplugin)
        super(brdrQDockWidgetFeatureAligner, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)


    def clearUserInterface(self):
        # Clear progressbar
        self.progressBar.setValue(0)
        self.doubleSpinBox.setValue(0)
        # Clear the featurelist widget
        self.listWidget_features.clear()
        # Clear the predictionlist
        self.listWidget_predictions.clear()
        self.checkBox_only_selected.setEnabled(True)

        remove_group_layer(self.GROUP_LAYER)
        self.feature = None


    def activate(self):
        self.active = True
        # connect to provide cleanup on closing of dockwidget
        self.closingPlugin.connect(self.onClosePlugin)
        self.pushButton_help.clicked.connect(self.show_help_dialog)
        self.pushButton_settings.clicked.connect(
            self.show_settings_dialog
        )
        self.pushButton_grafiek.clicked.connect(self.get_graphic)
        self.pushButton_visualisatie.clicked.connect(
            self.get_visualisation
        )
        self.pushButton_save.clicked.connect(self.change_geometry)
        self.pushButton_reset.clicked.connect(self.reset_geometry)
        self.pushButton_select.clicked.connect(self.activate_selectTool)
        self.mMapLayerComboBox.setFilters(
            QgsMapLayerProxyModel.PolygonLayer
        )
        self.mMapLayerComboBox.layerChanged.connect(self.themeLayerChanged)
        self.checkBox_only_selected.stateChanged.connect(
            self.themeLayerChanged
        )
        self.listWidget_features.itemPressed.connect(
            self.onFeatureActivated
        )
        self.listWidget_predictions.itemPressed.connect(
            self.onListItemActivated
        )
        self.horizontalSlider.sliderMoved.connect(self.onSliderChange)
        self.doubleSpinBox.valueChanged.connect(self.onSpinboxChange)

        # show the dockwidget
        self.iface.addDockWidget(Qt.RightDockWidgetArea, self)
        #
        self.layer = self.mMapLayerComboBox.currentLayer()
        self.settingsDialog.confirmed.connect(self.startDock)
        self.startDock()
        self.show()

    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""
        print ("** CLOSING brdrQ")
        remove_group_layer(self.GROUP_LAYER)
        # disconnects
        print("** disconnect dockwidget")
        self.closingPlugin.disconnect(self.onClosePlugin)
        self.active = False

    def activate_selectTool(self):
        print("button pushed")
        print ("currentlayer:" + str (self.mMapLayerComboBox.currentLayer()))
        self.selectTool = SelectTool(self.iface, self.mMapLayerComboBox.currentLayer())
        self.formerMapTool = self.iface.mapCanvas().mapTool()
        self.iface.mapCanvas().setMapTool(self.selectTool)
        self.selectTool.featuresIdentified.connect(self.onFeaturesIdentified)
        print("end activate_selecttool")

    def deactivateSelectTool(self):
        mapcanvas =self.iface.mapCanvas()
        if self.formerMapTool is None:
            self.formerMapTool = QgsMapToolPan(mapcanvas)
        mapcanvas.setMapTool(self.formerMapTool)

    def onFeaturesIdentified(self,identified_features):
        """Code called when the feature is selected by the user"""
        self.listed_features = identified_features
        self.listFeatures()
    def themeLayerChanged(self):
        #reset interface by clearing list, progress_bar
        self.clearUserInterface()
        self.layer = self.mMapLayerComboBox.currentLayer()
        if self.layer is None:
            self.textEdit_output.setText("Please select a layer")
            return
        if self.layer.selectedFeatureCount() > self.max_feature_count or (
            self.layer.selectedFeatureCount() == 0
            and self.layer.featureCount() > self.max_feature_count
        ):
            self.textEdit_output.setText(
                f"Nr of features bigger than {str(self.max_feature_count)}. Please make a smaller selection of features"
            )
            return

        if self.checkBox_only_selected.checkState()==2:
            self.listed_features = [f for f in self.layer.getSelectedFeatures()]
            self.textEdit_output.setText(
                "Selected features in this layer returned"
            )
        else:
            self.listed_features = [f for f in self.layer.getFeatures()]
            self.textEdit_output.setText(
                "All features in this layer returned"
            )
        self.listFeatures()

    def listFeatures(self):
        self.clearUserInterface()
        # Add the selected features to the list widget
        print ("list features")
        print(str(self.listed_features))
        for feature in self.listed_features:
            attributes = feature.attributes()
            attribute_string = ", ".join(str(attribute) for attribute in attributes)
            item = QListWidgetItem(
                f"ID: *{feature.id()}*, Attributes: {attribute_string}"
            )
            self.listWidget_features.addItem(item)
        self.textEdit_output.setText(
            f"#Features: {str(len(self.listed_features))}"
        )
        if len(self.listed_features) == 1:
            self.onFeatureActivated(self.listWidget_features.item(0))
        return

    def onFeatureActivated(self, currentItem):
        self.deactivateSelectTool()
        self.progressBar.setValue(0)
        self.listWidget_predictions.clear()
        self.textEdit_output.setText("")
        with OverrideCursor(Qt.WaitCursor):
            self._onFeatureChange(currentItem)
        self.progressBar.setValue(100)

    def _onFeatureChange(self, currentItem):
        print("_onFeatureChange")
        self.feature = None
        if currentItem is None:
            print("currentItem is none")
            return
        feature_id = currentItem.text().split("*")[1]
        for feat in self.listed_features:
            if str(feat.id()) == feature_id:
                self.feature = feat
                break
        if self.feature is None:
            self.textEdit_output.setText(
                f"No feature found with ID {feature_id}"
            )
            return

        self.original_geometry = self.feature.geometry()
        zoom_to_feature(self.feature, self.iface)
        key = self.feature.id()

        # Check feature on area
        # check area of feature and optimize/block calculation
        area = self.original_geometry.area()
        step = 10
        if area > self.max_area_optimization:
            if area > self.max_area_limit:
                msg = f"Very big area, {str(area)} m²: The calculation is blocked. Please use the bulk tool for this feature"
                self.textEdit_output.setText(f"{msg}")
                self.doubleSpinBox.setValue(0)
                self.listWidget_predictions.clear()
                return
            else:
                msg = f"Warning - Big area, {str(area)} m²: the calculation will be adapted/optimized. Only for every meter a calculation will be done"
                self.textEdit_output.setText(f"{msg}")
                step = 100

        #adapt & reload settings (espacially relevant_distances) before alignment
        self.settingsDialog.step = step
        self.loadSettings()
        self.setHandles()
        # do alignment/prediction
        self._align()

        fcs = self.aligner.get_results_as_geojson(
            resulttype=AlignerResultType.PROCESSRESULTS, formula=self.formula
        )

        geojson_to_layer(
            self.LAYER_RESULT_DIFF,
            fcs["result_diff"],
            QgsStyle.defaultStyle().symbol("hashed black X"),
            False,
            self.GROUP_LAYER,
            self.tempfolder,
        )
        geojson_to_layer(
            self.LAYER_RESULT_DIFF_PLUS,
            fcs["result_diff_plus"],
            QgsStyle.defaultStyle().symbol("hashed cgreen /"),
            True,
            self.GROUP_LAYER,
            self.tempfolder,
        )
        geojson_to_layer(
            self.LAYER_RESULT_DIFF_MIN,
            fcs["result_diff_min"],
            QgsStyle.defaultStyle().symbol("hashed cred /"),
            True,
            self.GROUP_LAYER,
            self.tempfolder,
        )
        geojson_to_layer(
            self.LAYER_RESULT,
            fcs["result"],
            QgsStyle.defaultStyle().symbol("outline green"),
            True,
            self.GROUP_LAYER,
            self.tempfolder,
        )

        # set list with predicted values
        self.listWidget_predictions.clear()
        # TODO, loop over predictions en voeg toe met boodschap
        items = []
        items_with_name = []
        best_index = 0
        best_score = 0
        list_predictions = [k for k in (self.dict_evaluated_predictions[key]).keys()]
        print(str(list_predictions))
        for k in list_predictions:
            print(str(k))
            items.append(str(k))
            score = self.props_dict_evaluated_predictions[key][k][PREDICTION_SCORE]
            evaluation = self.props_dict_evaluated_predictions[key][k][
                EVALUATION_FIELD_NAME
            ]
            items_with_name.append(f"{str(k)}: {str(evaluation)} (score: {str(score)})")
            if score > best_score:
                best_score = score
                best_index = list_predictions.index(k)
                print("best index: " + str(best_index))
        self.listWidget_predictions.setFocus()
        self.listWidget_predictions.addItems(items_with_name)
        if len(items) > 0:
            self.listWidget_predictions.setCurrentRow(best_index)
            print ("best-index: "+str(items[best_index]))
            self.doubleSpinBox.setValue(round(float(items[best_index]), self.settingsDialog.DECIMAL))
        else:
            self.textEdit_output.setText("No predictions")
        return

    def onListItemActivated(self, currentItem):
        print("onListItemActivated")
        self.deactivateSelectTool()
        self._listItemActivated(currentItem)

    def _align(self):
        feat = self.feature
        selectedFeatures = []
        if feat is not None:
            selectedFeatures.append(feat)
        if len(selectedFeatures) == 0:
            self.textEdit_output.setText(
                "Geen features geselecteerd. Gelieve een feature te selecteren uit de actieve laag"
            )
            return

        dict_to_load = {}

        self.progressBar.setValue(0)
        for feature in selectedFeatures:
            feature_geom = feature.geometry()
            wkt = feature_geom.asWkt()
            geom_shapely = geom_from_wkt(wkt)
            dict_to_load[feature.id()] = geom_shapely

        # Load thematic data
        self.aligner.load_thematic_data(DictLoader(dict_to_load))
        self.progressBar.setValue(25)
        # Load reference data for the on-the fly reference versions

        if self.reference_choice in GRB_TYPES:
            self.aligner.load_reference_data(
                GRBActualLoader(
                    grb_type=GRBType[self.reference_choice],
                    partition=1000,
                    aligner=self.aligner,
                )
            )
            print("grbtype")
        elif self.reference_choice in ADPF_VERSIONS:
            year = self.reference_choice.removeprefix("Adpf")
            self.aligner.load_reference_data(
                GRBFiscalParcelLoader(year=year, aligner=self.aligner, partition=1000)
            )
            print("adpftype")
        else:
            print("localtype")
            # Load reference into a shapely_dict:
            dict_reference = {}
            processing.run(
                "native:selectwithindistance",
                {
                    "INPUT": self.reference_layer,
                    "REFERENCE": self.layer,
                    "DISTANCE": 2 * self.maximum / 100,
                    "METHOD": 0,
                },
            )
            features = self.reference_layer.selectedFeatures()
            for current, feature in enumerate(features):
                id_reference = feature.attribute(self.reference_id)
                dict_reference[id_reference] = geom_qgis_to_shapely(feature.geometry())
            self.reference_layer.removeSelection()
            self.aligner.load_reference_data(DictLoader(dict_reference))
            self.aligner.name_reference_id = self.reference_id
            self.aligner.dict_reference_source["source"] = "local"
            self.aligner.dict_reference_source["version_date"] = "unknown"
        self.progressBar.setValue(50)

        dict_evaluated, props_dict_evaluated_predictions = self.aligner.evaluate(
            ids_to_evaluate=None,
            base_formula_field=None,
            all_predictions=True,
            relevant_distances=self.relevant_distances,
            prefer_full=self.full_parcel,
        )

        self.dict_processresults = self.aligner.dict_processresults
        self.dict_evaluated_predictions = dict_evaluated
        self.props_dict_evaluated_predictions = props_dict_evaluated_predictions
        self.diffs_dict = diffs_from_dict_processresults(
            self.dict_processresults, self.aligner.dict_thematic
        )

        outputMessage = "Voorspelde relevante afstanden: " + str(
            [str(k) for k in self.dict_evaluated_predictions[feat.id()].keys()]
        )
        self.textEdit_output.setText(outputMessage)
        return (
            self.dict_processresults,
            self.dict_evaluated_predictions,
            self.diffs_dict,
        )

    def change_geometry(self):
        self._change_geometry(self.layer)

    def reset_geometry(self):
        self._reset_geometry(self.layer)

    def startDock(self):
        self.clearUserInterface()
        self.textEdit_output.setText("Please select a feature to align")
        self.loadSettings()
        self.setHandles()
        self.aligner = Aligner(
            od_strategy=self.od_strategy,
            threshold_overlap_percentage=self.threshold_overlap_percentage,
            partial_snapping=self.partial_snapping,
            partial_snapping_strategy=self.partial_snapping_strategy,
            snapping_max_segment_length=self.snap_max_segment_length,
        )
        return

def __init__():
    pass

