# -*- coding: utf-8 -*-
"""
/***************************************************************************
 brdrQDockWidget
                                 A QGIS plugin
 aligns thematic polygons to reference polygons
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-10-08
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Karel Dieussaert
        email                : karel.dieussaert@geosolutions.be
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

import numpy as np
from PyQt5.QtWidgets import QListWidgetItem
from brdr.aligner import Aligner
from brdr.constants import PREDICTION_SCORE, EVALUATION_FIELD_NAME
from brdr.enums import AlignerResultType, GRBType
from brdr.geometry_utils import geom_from_wkt
from brdr.grb import GRBActualLoader, GRBFiscalParcelLoader
from brdr.loader import DictLoader
from brdr.utils import diffs_from_dict_processresults
from qgis import processing
from qgis.PyQt import QtWidgets, uic
from qgis.PyQt.QtCore import Qt
from qgis.PyQt.QtCore import pyqtSignal
from qgis.core import QgsMapLayerProxyModel
from qgis.core import QgsStyle
from qgis.gui import QgsMapToolPan
from qgis.utils import OverrideCursor

from .brdrq_help import brdrQHelp
from .brdrq_settings import brdrQSettings
from .brdrq_utils import SelectTool, zoom_to_feature, geojson_to_layer, get_workfolder, get_layer_by_name, GRB_TYPES, \
    ADPF_VERSIONS, geom_qgis_to_shapely, plot_series, show_map, geom_shapely_to_qgis, remove_group_layer

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'brdrq_dockwidget_featurealigner.ui'))


class brdrQDockWidget(QtWidgets.QDockWidget, FORM_CLASS):
    closingPlugin = pyqtSignal()

    def __init__(self,brdrqplugin, parent=None):
        """Constructor."""
        super(brdrQDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.layer =None
        self.formula = None
        self.max_feature_count = 5000
        self.max_area_optimization = 100000
        self.max_area_limit = (
            400000  # maximum mÂ² where the calculation will be done for
        )
        self.listed_features =None
        self.feature = None
        self.active=False
        self.selectTool = None
        self.formerMapTool = None
        self.aligner = None
        self.brdrqplugin = brdrqplugin
        self.iface = self.brdrqplugin.iface

        self.minimum = 0
        self.maximum = 1500
        self.step = 10
        self.relevant_distances = None
        self.threshold_overlap_percentage = None
        self.od_strategy =None
        self.reference_choice = None
        self.reference_id = None
        self.reference_layer = None
        self.max_rel_dist = None
        self.formula = None
        self.full_parcel = None
        self.partial_snapping = None
        self.partial_snapping_strategy = None
        self.snap_max_segment_length = None
        self.settingsDialog = brdrQSettings()
        self.tempfolder = get_workfolder("", "brdrQ", temporary=True)

        self.dict_processresults = None
        self.dict_evaluated_predictions = None
        self.props_dict_evaluated_predictions = None
        self.diffs_dict = None

        self.GROUP_LAYER = "brdrQ_featurealigner"
        self.LAYER_RESULT = (
            "RESULT"  # parameter that holds the TOC layername of the result
        )
        self.LAYER_RESULT_DIFF = (
            "DIFF"  # parameter that holds the TOC layername of the resulting diff
        )

        self.LAYER_RESULT_DIFF_PLUS = "DIFF_PLUS"  # parameter that holds the TOC layername of the resulting diff_plus
        self.LAYER_RESULT_DIFF_MIN = "DIFF_MIN"  # parameter that holds the TOC layername of the resulting diff_min

        self.helpDialog = brdrQHelp()


    def clearUserInterface(self):
        # Clear progressbar
        self.progressBar.setValue(0)
        self.doubleSpinBox.setValue(0)
        # Clear the featurelist widget
        self.listWidget_features.clear()
        # Clear the predictionlist
        self.listWidget_predictions.clear()
        self.checkBox_only_selected.setEnabled(True)

        remove_group_layer(self.GROUP_LAYER)
        self.feature = None

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()

    def activate(self):
        self.active = True
        # connect to provide cleanup on closing of dockwidget
        self.closingPlugin.connect(self.onClosePlugin)
        self.pushButton_help.clicked.connect(self.show_help_dialog)
        self.pushButton_settings.clicked.connect(
            self.show_settings_dialog
        )
        self.pushButton_grafiek.clicked.connect(self.get_graphic)
        self.pushButton_visualisatie.clicked.connect(
            self.get_visualisation
        )
        self.pushButton_save.clicked.connect(self.change_geometry)
        self.pushButton_reset.clicked.connect(self.reset_geometry)
        self.pushButton_select.clicked.connect(self.activate_selectTool)
        self.mMapLayerComboBox.setFilters(
            QgsMapLayerProxyModel.PolygonLayer
        )
        self.mMapLayerComboBox.layerChanged.connect(self.themeLayerChanged)
        self.checkBox_only_selected.stateChanged.connect(
            self.themeLayerChanged
        )
        self.listWidget_features.itemPressed.connect(
            self.onFeatureActivated
        )
        self.listWidget_predictions.itemPressed.connect(
            self.onListItemActivated
        )
        self.horizontalSlider.sliderMoved.connect(self.onSliderChange)
        self.doubleSpinBox.valueChanged.connect(self.onSpinboxChange)

        # show the dockwidget
        self.iface.addDockWidget(Qt.RightDockWidgetArea, self)
        #
        self.layer = self.mMapLayerComboBox.currentLayer()
        self.settingsDialog.confirmed.connect(self.startDock)
        self.startDock()
        self.show()

    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""
        print ("** CLOSING brdrQ")
        remove_group_layer(self.GROUP_LAYER)
        # disconnects
        print("** disconnect dockwidget")
        self.closingPlugin.disconnect(self.onClosePlugin)
        self.active = False

    def activate_selectTool(self):
        print("button pushed")
        print ("currentlayer:" + str (self.mMapLayerComboBox.currentLayer()))
        self.selectTool = SelectTool(self.iface, self.mMapLayerComboBox.currentLayer())
        self.formerMapTool = self.iface.mapCanvas().mapTool()
        self.iface.mapCanvas().setMapTool(self.selectTool)
        self.selectTool.featuresIdentified.connect(self.onFeaturesIdentified)
        print("end activate_selecttool")

    def deactivateSelectTool(self):
        mapcanvas =self.iface.mapCanvas()
        if self.formerMapTool is None:
            self.formerMapTool = QgsMapToolPan(mapcanvas)
        mapcanvas.setMapTool(self.formerMapTool)


    def onFeaturesIdentified(self,identified_features):
        """Code called when the feature is selected by the user"""
        self.listed_features = identified_features
        self.listFeatures()
    def themeLayerChanged(self):
        #reset interface by clearing list, progress_bar
        self.clearUserInterface()
        self.layer = self.mMapLayerComboBox.currentLayer()
        if self.layer is None:
            self.textEdit_output.setText("Please select a layer")
            return
        if self.layer.selectedFeatureCount() > self.max_feature_count or (
            self.layer.selectedFeatureCount() == 0
            and self.layer.featureCount() > self.max_feature_count
        ):
            self.textEdit_output.setText(
                f"Nr of features bigger than {str(self.max_feature_count)}. Please make a smaller selection of features"
            )
            return

        if self.checkBox_only_selected.checkState()==2:
            self.listed_features = [f for f in self.layer.getSelectedFeatures()]
            self.textEdit_output.setText(
                "Selected features in this layer returned"
            )
        else:
            self.listed_features = [f for f in self.layer.getFeatures()]
            self.textEdit_output.setText(
                "All features in this layer returned"
            )
        self.listFeatures()

    def listFeatures(self):
        self.clearUserInterface()
        # Add the selected features to the list widget
        print ("list features")
        print(str(self.listed_features))
        for feature in self.listed_features:
            attributes = feature.attributes()
            attribute_string = ", ".join(str(attribute) for attribute in attributes)
            item = QListWidgetItem(
                f"ID: *{feature.id()}*, Attributes: {attribute_string}"
            )
            self.listWidget_features.addItem(item)
        self.textEdit_output.setText(
            f"#Features: {str(len(self.listed_features))}"
        )
        if len(self.listed_features) == 1:
            self.onFeatureActivated(self.listWidget_features.item(0))
        return

    def onFeatureActivated(self, currentItem):
        self.deactivateSelectTool()
        self.progressBar.setValue(0)
        self.listWidget_predictions.clear()
        self.textEdit_output.setText("")
        with OverrideCursor(Qt.WaitCursor):
            self._onFeatureChange(currentItem)
        self.progressBar.setValue(100)

    def _onFeatureChange(self, currentItem):
        print("_onFeatureChange")
        self.feature = None
        if currentItem is None:
            print("currentItem is none")
            return
        feature_id = currentItem.text().split("*")[1]
        for feat in self.listed_features:
            if str(feat.id()) == feature_id:
                self.feature = feat
                break
        if self.feature is None:
            self.textEdit_output.setText(
                f"No feature found with ID {feature_id}"
            )
            return

        self.original_geometry = self.feature.geometry()
        zoom_to_feature(self.feature, self.iface)
        key = self.feature.id()

        # Check feature on area
        # check area of feature and optimize/block calculation
        area = self.original_geometry.area()
        self.step = 10
        if area > self.max_area_optimization:
            if area > self.max_area_limit:
                msg = f"Very big area, {str(area)} mÂ²: The calculation is blocked. Please use the bulk tool for this feature"
                self.textEdit_output.setText(f"{msg}")
                self.doubleSpinBox.setValue(0)
                self.listWidget_predictions.clear()
                return
            else:
                msg = f"Warning - Big area, {str(area)} mÂ²: the calculation will be adapted/optimized. Only for every meter a calculation will be done"
                self.textEdit_output.setText(f"{msg}")
                self.step = 100
                self.relevant_distances = [
                    round(k, self.settingsDialog.DECIMAL)
                    for k in np.arange(
                        self.minimum, self.maximum + self.step, self.step, dtype=int
                    )
                             / 100
                ]

        # do alignment/prediction
        self._align()

        fcs = self.aligner.get_results_as_geojson(
            resulttype=AlignerResultType.PROCESSRESULTS, formula=self.formula
        )

        geojson_to_layer(
            self.LAYER_RESULT_DIFF,
            fcs["result_diff"],
            QgsStyle.defaultStyle().symbol("hashed black X"),
            False,
            self.GROUP_LAYER,
            self.tempfolder,
        )
        geojson_to_layer(
            self.LAYER_RESULT_DIFF_PLUS,
            fcs["result_diff_plus"],
            QgsStyle.defaultStyle().symbol("hashed cgreen /"),
            True,
            self.GROUP_LAYER,
            self.tempfolder,
        )
        geojson_to_layer(
            self.LAYER_RESULT_DIFF_MIN,
            fcs["result_diff_min"],
            QgsStyle.defaultStyle().symbol("hashed cred /"),
            True,
            self.GROUP_LAYER,
            self.tempfolder,
        )
        geojson_to_layer(
            self.LAYER_RESULT,
            fcs["result"],
            QgsStyle.defaultStyle().symbol("outline green"),
            True,
            self.GROUP_LAYER,
            self.tempfolder,
        )

        # set list with predicted values
        self.listWidget_predictions.clear()
        # TODO, loop over predictions en voeg toe met boodschap
        items = []
        items_with_name = []
        best_index = 0
        best_score = 0
        list_predictions = [k for k in (self.dict_evaluated_predictions[key]).keys()]
        print(str(list_predictions))
        for k in list_predictions:
            print(str(k))
            items.append(str(k))
            score = self.props_dict_evaluated_predictions[key][k][PREDICTION_SCORE]
            evaluation = self.props_dict_evaluated_predictions[key][k][
                EVALUATION_FIELD_NAME
            ]
            items_with_name.append(f"{str(k)}: {str(evaluation)} (score: {str(score)})")
            if score > best_score:
                best_score = score
                best_index = list_predictions.index(k)
                print("best index: " + str(best_index))
        self.listWidget_predictions.setFocus()
        self.listWidget_predictions.addItems(items_with_name)
        if len(items) > 0:
            self.listWidget_predictions.setCurrentRow(best_index)
            print ("best-index: "+str(items[best_index]))
            self.doubleSpinBox.setValue(round(float(items[best_index]), self.settingsDialog.DECIMAL))
        else:
            self.textEdit_output.setText("No predictions")

    def onListItemActivated(self, currentItem):
        print("onListItemActivated")
        self.deactivateSelectTool()
        self._listItemActivated(currentItem)

    def _listItemActivated(self, currentItem):

        if currentItem is None:
            print("currentitem zero")
            return
        print("item activated with rd: " + currentItem.text())
        value = currentItem.text()
        value = value.split(":")[0]
        value = round(float(value), self.settingsDialog.DECIMAL)
        print("item activated with rd - value: " + str(value))
        self.doubleSpinBox.setValue(value)
        index = self.relevant_distances.index(value)
        self.horizontalSlider.setValue(index)
        return

    def onSliderChange(self, index):
        print("onSliderChange: index -> " + str(index))
        value = self.relevant_distances[index]
        value = round(value, self.settingsDialog.DECIMAL)
        self.doubleSpinBox.setValue(value)
        return

    def onSpinboxChange(self, value):
        value = round(value, self.settingsDialog.DECIMAL)
        index = self.relevant_distances.index(value)
        self.horizontalSlider.setValue(index)
        print("onSpinboxChange: value -> " + str(value))

        # self.change_geometry()
        # Filter layers based on relevant distance
        get_layer_by_name(self.LAYER_RESULT).setSubsetString(
            f"brdr_relevant_distance = {value}"
        )
        get_layer_by_name(self.LAYER_RESULT_DIFF).setSubsetString(
            f"brdr_relevant_distance = {value}"
        )
        get_layer_by_name(self.LAYER_RESULT_DIFF_MIN).setSubsetString(
            f"brdr_relevant_distance = {value}"
        )
        get_layer_by_name(self.LAYER_RESULT_DIFF_PLUS).setSubsetString(
            f"brdr_relevant_distance = {value}"
        )
        self.get_wkt()
        return

    def _align(self):
        feat = self.feature
        selectedFeatures = []
        if feat is not None:
            selectedFeatures.append(feat)
        if len(selectedFeatures) == 0:
            self.textEdit_output.setText(
                "Geen features geselecteerd. Gelieve een feature te selecteren uit de actieve laag"
            )
            return

        dict_to_load = {}

        self.progressBar.setValue(0)
        for feature in selectedFeatures:
            feature_geom = feature.geometry()
            wkt = feature_geom.asWkt()
            geom_shapely = geom_from_wkt(wkt)
            dict_to_load[feature.id()] = geom_shapely

        # Load thematic data
        self.aligner.load_thematic_data(DictLoader(dict_to_load))
        self.progressBar.setValue(25)
        # Load reference data for the on-the fly reference versions

        if self.reference_choice in GRB_TYPES:
            self.aligner.load_reference_data(
                GRBActualLoader(
                    grb_type=GRBType[self.reference_choice],
                    partition=1000,
                    aligner=self.aligner,
                )
            )
            print("grbtype")
        elif self.reference_choice in ADPF_VERSIONS:
            year = self.reference_choice.removeprefix("Adpf")
            self.aligner.load_reference_data(
                GRBFiscalParcelLoader(year=year, aligner=self.aligner, partition=1000)
            )
            print("adpftype")
        else:
            print("localtype")
            # Load reference into a shapely_dict:
            dict_reference = {}
            processing.run(
                "native:selectwithindistance",
                {
                    "INPUT": self.reference_layer,
                    "REFERENCE": self.layer,
                    "DISTANCE": 2 * self.maximum / 100,
                    "METHOD": 0,
                },
            )
            features = self.reference_layer.selectedFeatures()
            for current, feature in enumerate(features):
                id_reference = feature.attribute(self.reference_id)
                dict_reference[id_reference] = geom_qgis_to_shapely(feature.geometry())
            self.reference_layer.removeSelection()
            self.aligner.load_reference_data(DictLoader(dict_reference))
            self.aligner.name_reference_id = self.reference_id
            self.aligner.dict_reference_source["source"] = "local"
            self.aligner.dict_reference_source["version_date"] = "unknown"
        self.progressBar.setValue(50)

        dict_evaluated, props_dict_evaluated_predictions = self.aligner.evaluate(
            ids_to_evaluate=None,
            base_formula_field=None,
            all_predictions=True,
            relevant_distances=self.relevant_distances,
            prefer_full=self.full_parcel,
        )

        self.dict_processresults = self.aligner.dict_processresults
        self.dict_evaluated_predictions = dict_evaluated
        self.props_dict_evaluated_predictions = props_dict_evaluated_predictions
        self.diffs_dict = diffs_from_dict_processresults(
            self.dict_processresults, self.aligner.dict_thematic
        )

        outputMessage = "Voorspelde relevante afstanden: " + str(
            [str(k) for k in self.dict_evaluated_predictions[feat.id()].keys()]
        )
        self.textEdit_output.setText(outputMessage)
        return (
            self.dict_processresults,
            self.dict_evaluated_predictions,
            self.diffs_dict,
        )

    def show_help_dialog(self):
        self.helpDialog.show()

    def show_settings_dialog(self):
        self.settingsDialog.show()

    def get_graphic(self):
        feat = self.feature
        if feat is None:
            return
        key = feat.id()
        plot_series(self.relevant_distances, {key: self.diffs_dict[key]})
        return

    def get_visualisation(self):
        feat = self.feature
        if feat is None:
            return
        key = feat.id()
        show_map(
            {key: self.dict_evaluated_predictions[key]},
            {key: self.aligner.dict_thematic[key]},
            self.aligner.dict_reference,
        )
        return

    def change_geometry(self):
        feat = self.feature
        if feat is None:
            return
        key = feat.id()
        relevant_distance = round(self.doubleSpinBox.value(),self.settingsDialog.DECIMAL)
        if relevant_distance in self.dict_processresults[key]:
            result = self.dict_processresults[key][relevant_distance]
            resulting_geom = result["result"]
        else:
            errormesssage = "Relevant_distance_result not calculated for: " + str(
                relevant_distance
            )
            print(errormesssage)
            return
        layer = self.layer
        layer.startEditing()
        qgis_geom = geom_shapely_to_qgis(resulting_geom)
        layer.changeGeometry(feat.id(), qgis_geom)
        layer.commitChanges()
        self.iface.messageBar().pushMessage("geometrie aangepast")

    def reset_geometry(self):
        feat = self.feature
        if feat is None:
            return
        layer = self.layer
        layer.startEditing()
        layer.changeGeometry(feat.id(), self.original_geometry)
        layer.commitChanges()
        self.iface.messageBar().pushMessage("geometrie gereset")

    def get_wkt(self):
        feat = self.feature
        if feat is None:
            return
        key = feat.id()
        print ("key:" + str(key))
        relevant_distance = round(self.doubleSpinBox.value(),self.settingsDialog.DECIMAL)
        print (str(relevant_distance))
        if key is None or self.dict_processresults is None or not key in self.dict_processresults.keys():
            msg = f"No prediction-WKT of feature {str(key)}..."
            self.textEdit_output.setText(msg)
            return

        elif relevant_distance in self.dict_processresults[key]:
            result = self.dict_processresults[key][relevant_distance]
            resulting_geom = result["result"]
        else:
            errormesssage = "Relevant_distance_result not calculated for key : " + str(
                key
            )+ " at relevant distance-" + str(
                relevant_distance
            )

            self.textEdit_output.setText(errormesssage)
            return
        wkt = resulting_geom.wkt
        self.textEdit_output.setText(wkt)

    def startDock(self):
        self.clearUserInterface()

        self.textEdit_output.setText("Please select a feature to align")

        self.threshold_overlap_percentage = self.settingsDialog.threshold_overlap_percentage
        self.od_strategy = self.settingsDialog.od_strategy
        self.reference_choice = self.settingsDialog.reference_choice
        self.reference_id = self.settingsDialog.reference_id
        self.reference_layer = self.settingsDialog.reference_layer
        self.max_rel_dist = self.settingsDialog.max_rel_dist
        self.relevant_distances = self.settingsDialog.relevant_distances
        self.formula = self.settingsDialog.formula
        self.full_parcel = self.settingsDialog.full_parcel
        self.partial_snapping = self.settingsDialog.partial_snapping
        self.partial_snapping_strategy = self.settingsDialog.partial_snapping_strategy
        self.snap_max_segment_length = self.settingsDialog.snap_max_segment_length

        self.doubleSpinBox.setMinimum(self.minimum / 100)
        self.doubleSpinBox.setMaximum(self.maximum / 100)
        self.doubleSpinBox.setSingleStep(self.step / 100)
        self.doubleSpinBox.setDecimals(self.settingsDialog.DECIMAL)
        self.doubleSpinBox.setValue(0.0)
        self.horizontalSlider.setMinimum(0)
        self.horizontalSlider.setMaximum(
            len(self.relevant_distances) - 1
        )
        self.horizontalSlider.setSingleStep(1)

        self.aligner = Aligner(
            od_strategy=self.od_strategy,
            threshold_overlap_percentage=self.threshold_overlap_percentage,
            partial_snapping=self.partial_snapping,
            partial_snapping_strategy=self.partial_snapping_strategy,
            snapping_max_segment_length=self.snap_max_segment_length,
        )
def __init__():
    pass

