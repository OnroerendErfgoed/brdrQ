# -*- coding: utf-8 -*-

"""
/***************************************************************************
 BrdrQ
                                 A QGIS plugin
 brdrQ, a QGIS-plugin for aligning thematic borders to reference borders.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-10-11
        copyright            : (C) 2024 by Karel Dieussaert / Onroerend Erfgoed
        email                : karel.dieussaert@vlaanderen.be
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Karel Dieussaert / Onroerend Erfgoed'
__date__ = '2024-10-11'
__copyright__ = '(C) 2024 by Karel Dieussaert / Onroerend Erfgoed'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

import inspect
import os
import sys

import numpy as np
from PyQt5.QtGui import QIcon
from PyQt5.QtWidgets import QAction, QListWidgetItem
from qgis.PyQt.QtCore import QCoreApplication
from qgis.PyQt.QtCore import Qt
from qgis.core import QgsApplication
from qgis.core import QgsProject
from qgis.core import QgsSimpleLineSymbolLayer, QgsFillSymbol, \
    QgsSingleSymbolRenderer, QgsMapLayer, QgsLayerTreeNode, QgsLayerTreeGroup
from qgis.core import QgsStyle, QgsVectorLayer
from shapely.io import from_wkt

from .brdrq_dockwidget import brdrQDockWidget
from .brdrq_provider import BrdrQProvider
from .brdrq_utils import plot_series, show_map, geom_shapely_to_qgis

cmd_folder = os.path.split(inspect.getfile(inspect.currentframe()))[0]

if cmd_folder not in sys.path:
    sys.path.insert(0, cmd_folder)

# try:
#     import brdr
# except:
#     import brdr
#     print("Module brdr not found. Please install it manually: pip install brdr==0.4.0")
try:
    from geojson import dump
except:
    from geojson import dump
from brdr.aligner import Aligner
from brdr.grb import GRBActualLoader
from brdr.enums import GRBType, AlignerResultType
from brdr.geometry_utils import geojson_polygon_to_multipolygon
from brdr.loader import DictLoader


class BrdrQPlugin(object):

    def __init__(self, iface):
        self.provider = None
        self.iface = iface
        self.dockwidget = None
        self.pluginIsActive = False
        self.actions = []
        # self.menu = self.tr('brdrQ')
        self.toolbar = self.iface.addToolBar('brdrQ')
        self.toolbar.setObjectName('brdrQ')
        self.minimum = 0
        self.maximum = 600
        self.step = 10
        self.relevant_distances = np.arange(self.minimum, self.maximum + self.step, self.step, dtype=int) / 100
        self.max_feature_count = 5000
        self.layer = None
        self.selected_features = None
        self.feature = None
        self.dict_series = None
        self.dict_predictions = None
        self.diffs_dict = None
        self.aligner = Aligner()
        self.original_geometry = None
        self.GROUP_LAYER = "brdrQ_plugin"
        self.TEMPFOLDER = "brdrQ"
        self.LAYER_RESULT = "RESULT"  # parameter that holds the TOC layername of the result
        self.LAYER_RESULT_DIFF = "DIFF"  # parameter that holds the TOC layername of the resulting diff
        self.LAYER_RESULT_DIFF_PLUS = "DIFF_PLUS"  # parameter that holds the TOC layername of the resulting diff_plus
        self.LAYER_RESULT_DIFF_MIN = "DIFF_MIN"  # parameter that holds the TOC layername of the resulting diff_min

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('brdrQ', message)

    def initProcessing(self):
        """Init Processing provider for QGIS >= 3.8."""

        self.provider = BrdrQProvider()
        QgsApplication.processingRegistry().addProvider(self.provider)

    def initGui(self):
        self.initProcessing()
        icon = os.path.join(os.path.join(cmd_folder, 'icon.png'))
        action = QAction(QIcon(icon), 'brdrQ - Align borders', self.iface.mainWindow())
        action.triggered.connect(self.openDock)
        # self.iface.addToolBarIcon(action)
        self.iface.addPluginToMenu("brdQ menu", action)
        self.toolbar.addAction(action)
        self.actions.append(action)
        # show the dockwidget
        # self.openDock()

    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""
        pass
        # print "** CLOSING brdrQ"
        tree = QgsProject.instance().layerTreeRoot()
        node_object = tree.findGroup(self.GROUP_LAYER)
        tree.removeChildNode(node_object)

        # disconnects
        self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)

        # remove this statement if dockwidget is to remain
        # for reuse if plugin is reopened
        # Commented next statement since it causes QGIS crashe
        # when closing the docked window:
        # self.dockwidget = None

        self.pluginIsActive = False

    def unload(self):
        QgsApplication.processingRegistry().removeProvider(self.provider)
        for action in self.actions:
            self.iface.removePluginMenu('brdrQ',
                                        action)
            self.iface.removeToolBarIcon(action)
            self.toolbar.removeAction(action)
            self.iface.removePluginMenu("brdQ menu", action)
            del action
        # remove the toolbar
        del self.toolbar

    def openDock(self):
        if not self.pluginIsActive:
            self.pluginIsActive = True

            # print "** STARTING brdrQ"

            # dockwidget may not exist if:
            #    first run of plugin
            #    removed on close (see self.onClosePlugin method)
            if self.dockwidget == None:
                # Create the dockwidget (after translation) and keep reference
                self.dockwidget = brdrQDockWidget()

            self.dockwidget.horizontalSlider.setMinimum(self.minimum)
            self.dockwidget.horizontalSlider.setMaximum(self.maximum)
            self.dockwidget.horizontalSlider.setSingleStep(self.step)
            self.dockwidget.doubleSpinBox.setMinimum(self.minimum / 100)
            self.dockwidget.doubleSpinBox.setMaximum(self.maximum / 100)
            self.dockwidget.doubleSpinBox.setSingleStep(self.step / 100)
            self.dockwidget.doubleSpinBox.setDecimals(1)
            # connect to provide cleanup on closing of dockwidget
            self.dockwidget.closingPlugin.connect(self.onClosePlugin)
            self.dockwidget.pushButton_grafiek.clicked.connect(self.get_graphic)
            self.dockwidget.pushButton_visualisatie.clicked.connect(self.get_visualisation)
            self.dockwidget.pushButton_save.clicked.connect(self.change_geometry)
            self.dockwidget.pushButton_reset.clicked.connect(self.reset_geometry)
            # self.dockwidget.pushButton_select.clicked.connect(self.start_line_edit)
            self.dockwidget.pushButton_wkt.clicked.connect(self.get_wkt)
            # self.dockwidget.mMapLayerComboBox.layerChanged.connect(self.setIds)
            self.dockwidget.mMapLayerComboBox.layerChanged.connect(self.setFeatures)
            # self.dockwidget.mFeaturePickerWidget.featureChanged.connect(self.onFeatureChange)
            self.dockwidget.listWidget_features.currentItemChanged.connect(self.onFeatureChange)
            self.dockwidget.listWidget_features.itemActivated.connect(self.onFeatureActivated)
            self.dockwidget.listWidget_features.itemClicked.connect(self.onFeatureActivated)
            self.dockwidget.listWidget_predictions.currentItemChanged.connect(self.onListItemChange)
            self.dockwidget.listWidget_predictions.itemActivated.connect(self.onListItemActivated)
            self.dockwidget.listWidget_predictions.itemClicked.connect(self.onListItemActivated)
            # self.dockwidget.horizontalSlider.valueChanged.connect(self.onSliderChange)
            self.dockwidget.horizontalSlider.sliderMoved.connect(self.onSliderChange)
            self.dockwidget.doubleSpinBox.valueChanged.connect(self.onSpinboxChange)

            # show the dockwidget
            # TODO: fix to allow choice of dock location
            self.iface.addDockWidget(Qt.RightDockWidgetArea, self.dockwidget)
            # self.dockwidget.show()
            self.layer = self.dockwidget.mMapLayerComboBox.currentLayer()

    # def setIds(self):
    #     picker = self.dockwidget.mFeaturePickerWidget
    #     layer = self.dockwidget.mMapLayerComboBox.currentLayer()
    #     picker.setLayer(layer)
    #     picker.setDisplayExpression('$id')  # show ids in combobox

    def setFeatures(self):
        self.layer = self.dockwidget.mMapLayerComboBox.currentLayer()
        if self.layer.selectedFeatureCount() > self.max_feature_count or (
                self.layer.selectedFeatureCount() == 0 and self.layer.featureCount() > self.max_feature_count):
            self.dockwidget.textEdit_output.setText(
                f"Nr of features bigger than {str(self.max_feature_count)}. Please make a smaller selection of features")
            return
        self.selected_features = [f for f in self.layer.getSelectedFeatures()]
        if self.layer.selectedFeatureCount() == 0:
            self.selected_features = [f for f in self.layer.getFeatures()]
            self.dockwidget.textEdit_output.setText("No selected features in this layer, all features returned")

        # Clear the list widget
        self.dockwidget.listWidget_features.clear()

        # Add the selected features to the list widget
        for feature in self.selected_features:
            attributes = feature.attributes()
            attribute_string = ", ".join(str(attribute) for attribute in attributes)
            item = QListWidgetItem(f"ID: *{feature.id()}*, Attributes: {attribute_string}")
            self.dockwidget.listWidget_features.addItem(item)
        self.dockwidget.textEdit_output.setText(f"#Features: {str(len(self.selected_features))}")
        return

    def onFeatureChange(self, currentItem, previousItem):
        self._onFeatureChange(currentItem)

    def onFeatureActivated(self, currentItem):
        self._onFeatureChange(currentItem)

    def _onFeatureChange(self, currentItem):
        print("_onFeatureChange")
        self.feature = None
        if currentItem is None:
            print("currentItem is none")
            return
        feature_id = currentItem.text().split('*')[1]
        print(f"Feature_id is {feature_id}")
        for feat in self.selected_features:
            print(str(feat.id()))
            if str(feat.id()) == feature_id:
                print("equal - >break")
                self.feature = feat
                break
        print(self.feature)
        if self.feature is None:
            self.dockwidget.textEdit_output.setText(f"No feature found with ID {feature_id}")
            return

        # zoom to feature
        self.original_geometry = self.feature.geometry()
        box = self.feature.geometry().boundingBox()
        self.iface.mapCanvas().setExtent(box)
        self.iface.mapCanvas().refresh()
        key = self.feature.id()

        # do alignment/prediction
        self._align()

        fcs = self.aligner.get_results_as_geojson(resulttype=AlignerResultType.PROCESSRESULTS)

        self.geojson_to_layer(self.LAYER_RESULT_DIFF, fcs["result_diff"],
                              QgsStyle.defaultStyle().symbol("hashed black X"),
                              False, self.GROUP_LAYER)
        self.geojson_to_layer(self.LAYER_RESULT_DIFF_PLUS, fcs["result_diff_plus"],
                              QgsStyle.defaultStyle().symbol("hashed cgreen /"),
                              True, self.GROUP_LAYER)
        self.geojson_to_layer(self.LAYER_RESULT_DIFF_MIN, fcs["result_diff_min"],
                              QgsStyle.defaultStyle().symbol("hashed cred /"),
                              True, self.GROUP_LAYER)
        self.geojson_to_layer(self.LAYER_RESULT, fcs["result"],
                              QgsStyle.defaultStyle().symbol("outline green"),
                              True, self.GROUP_LAYER)

        # set list with predicted values
        self.dockwidget.listWidget_predictions.clear()
        items = [str(k) for k in self.dict_predictions[key]]
        self.dockwidget.listWidget_predictions.addItems(items)
        if len(items) > 0:
            self.dockwidget.doubleSpinBox.setValue(float(items[0]))
            self.dockwidget.listWidget_predictions.setCurrentRow(1)

    def onListItemChange(self, currentItem, previousItem):
        self._listItemActivated(currentItem)

    def onListItemActivated(self, currentItem):
        self._listItemActivated(currentItem)

    def _listItemActivated(self, currentItem):

        if currentItem is None:
            return
        value = float(currentItem.text())
        self.dockwidget.doubleSpinBox.setValue(value)
        self.dockwidget.horizontalSlider.setValue(int(100 * value))
        return

    def onSliderChange(self, value):
        self.dockwidget.doubleSpinBox.setValue(value / 100)
        return

    def onSpinboxChange(self, value):
        self.dockwidget.horizontalSlider.setValue(int(value * 100))

        # self.change_geometry()
        # Filter layers based on relevant distance
        self.get_layer_by_name(self.LAYER_RESULT).setSubsetString(f"brdr_relevant_distance = {value}")
        self.get_layer_by_name(self.LAYER_RESULT_DIFF).setSubsetString(f"brdr_relevant_distance = {value}")
        self.get_layer_by_name(self.LAYER_RESULT_DIFF_MIN).setSubsetString(f"brdr_relevant_distance = {value}")
        self.get_layer_by_name(self.LAYER_RESULT_DIFF_PLUS).setSubsetString(f"brdr_relevant_distance = {value}")
        return

    # def start_line_edit(self):
    #     print("button pushed")
    #     self.t = selectTool(self.iface, self.dockwidget.mMapLayerComboBox.currentLayer())
    #     self.iface.mapCanvas().setMapTool(self.t)

    def get_graphic(self):
        # feat = self.dockwidget.mFeaturePickerWidget.feature()
        feat = self.feature
        key = feat.id()
        plot_series(self.relevant_distances, {key: self.diffs_dict[key]})

    def get_visualisation(self):
        # feat = self.dockwidget.mFeaturePickerWidget.feature()
        feat = self.feature
        key = feat.id()
        show_map(
            {key: self.dict_predictions[key]},
            {key: self.aligner.dict_thematic[key]},
            self.aligner.dict_reference,
        )

    def change_geometry(self):
        # feat = self.dockwidget.mFeaturePickerWidget.feature()
        feat = self.feature
        key = feat.id()
        relevant_distance = self.dockwidget.doubleSpinBox.value()
        if relevant_distance in self.dict_series[key]:
            result = self.dict_series[key][relevant_distance]
            resulting_geom = result['result']
        else:
            errormesssage = "Relevant_distance_result not calculated for: " + str(relevant_distance)
            self.iface.messageBar().pushMessage(errormesssage)
            print(errormesssage)
            return
        # layer = self.dockwidget.mMapLayerComboBox.currentLayer()
        layer = self.layer
        layer.startEditing()
        qgis_geom = geom_shapely_to_qgis(resulting_geom)
        layer.changeGeometry(feat.id(), qgis_geom)
        layer.commitChanges()
        self.iface.messageBar().pushMessage("geometrie aangepast")

    def reset_geometry(self):
        # feat = self.dockwidget.mFeaturePickerWidget.feature()
        feat = self.feature
        # layer = self.dockwidget.mMapLayerComboBox.currentLayer()
        layer = self.layer
        layer.startEditing()
        layer.changeGeometry(feat.id(), self.original_geometry)
        layer.commitChanges()
        self.iface.messageBar().pushMessage("geometrie gereset")

    def get_wkt(self):
        # feat = self.dockwidget.mFeaturePickerWidget.feature()
        feat = self.feature
        key = feat.id()
        relevant_distance = self.dockwidget.doubleSpinBox.value()
        if relevant_distance in self.dict_series[key]:
            result = self.dict_series[key][relevant_distance]
            resulting_geom = result['result']
        else:
            errormesssage = "Relevant_distance_result not calculated for: " + str(relevant_distance)
            self.iface.messageBar().pushMessage(errormesssage)
            self.dockwidget.textEdit_output.setText(errormesssage)
            return
        wkt = resulting_geom.wkt
        self.dockwidget.textEdit_output.setText(wkt)

    def _align(self):

        # brdr_version = str(brdr.__version__)
        # feat = self.dockwidget.mFeaturePickerWidget.feature()
        feat = self.feature
        selectedFeatures = []
        if feat is not None:
            selectedFeatures.append(feat)
        if len(selectedFeatures) == 0:
            self.dockwidget.textEdit_output.setText(
                "Geen features geselecteerd. Gelieve een feature te selecteren uit de actieve laag")
            return
        # take selected feature(s)
        # run brdr (to actual GRB) for this feature
        list = []
        self.aligner = Aligner()

        # i = 0
        dict_to_load = {}

        for feature in selectedFeatures:
            # i = i + 1
            feature_geom = feature.geometry()
            wkt = feature_geom.asWkt()
            geom_shapely = from_wkt(wkt)
            dict_to_load[feature.id()] = geom_shapely
        # Load thematic &reference data
        self.aligner.load_thematic_data(DictLoader(dict_to_load))
        loader = GRBActualLoader(grb_type=GRBType.ADP, partition=1000, aligner=self.aligner)
        self.aligner.load_reference_data(loader)

        self.dict_series, self.dict_predictions, self.diffs_dict = self.aligner.predictor(
            relevant_distances=self.relevant_distances)
        outputMessage = "Voorspelde relevante afstanden: " + str(
            [str(k) for k in self.dict_predictions[feat.id()].keys()])

        self.dockwidget.textEdit_output.setText(outputMessage)
        self.iface.messageBar().pushMessage(outputMessage)
        return self.dict_series, self.dict_predictions, self.diffs_dict

    def geojson_to_layer(self, name, geojson, symbol, visible, group):
        """
        Add a geojson to a QGIS-layer to add it to the TOC
        """
        qinst = QgsProject.instance()
        lyrs = qinst.mapLayersByName(name)
        root = qinst.layerTreeRoot()

        if len(lyrs) != 0:
            for lyr in lyrs:
                root.removeLayer(lyr)
                qinst.removeMapLayer(lyr.id())

        tempfilename = self.TEMPFOLDER + "/" + name + ".geojson"
        self.write_geojson(tempfilename, geojson_polygon_to_multipolygon(geojson))

        vl = QgsVectorLayer(tempfilename, name, "ogr")
        # styling
        if symbol is not None and vl.renderer() is not None:
            vl.renderer().setSymbol(symbol)
        # vl.setOpacity(0.5)

        # adding layer to TOC
        qinst.addMapLayer(
            vl, False
        )  # False so that it doesn't get inserted at default position

        root.insertLayer(0, vl)

        node = root.findLayer(vl.id())
        if node:
            new_state = Qt.Checked if visible else Qt.Unchecked
            node.setItemVisibilityChecked(new_state)

        self.move_to_group(vl, group)
        vl.triggerRepaint()
        self.iface.layerTreeView().refreshLayerSymbology(vl.id())
        return vl

    def move_to_group(self, thing, group, pos=0, expanded=False):
        """Move a layer tree node into a layer tree group.
        docs:https://docs.qgis.org/3.34/en/docs/pyqgis_developer_cookbook/cheat_sheet.html

        Parameter
        ---------

        thing : group name (str), layer id (str), qgis.core.QgsMapLayer, qgis.core.QgsLayerTreeNode

          Thing to move.  Can be a tree node (i.e. a layer or a group) or
          a map layer, the object or the string name/id.

        group : group name (str) or qgis.core.QgsLayerTreeGroup

          Group to move the thing to. If group does not already exist, it
          will be created.

        pos : int

          Position to insert into group. Default is 0.

        extended : bool

          Collapse or expand the thing moved. Default is False.

        Returns
        -------

        Tuple containing the moved thing and the group moved to.

        Note
        ----

        Moving destroys the original thing and creates a copy. It is the
        copy which is returned.

        """

        qinst = QgsProject.instance()
        tree = qinst.layerTreeRoot()

        # thing
        if isinstance(thing, str):
            try:  # group name
                node_object = tree.findGroup(thing)
            except:  # layer id
                node_object = tree.findLayer(thing)
        elif isinstance(thing, QgsMapLayer):
            node_object = tree.findLayer(thing)
        elif isinstance(thing, QgsLayerTreeNode):
            node_object = thing  # tree layer or group

        # group
        if isinstance(group, QgsLayerTreeGroup):
            group_name = group.name()
        else:  # group is str
            group_name = group

        group_object = tree.findGroup(group_name)

        if not group_object:
            group_object = tree.insertGroup(0, group_name)

        # do the move
        node_object_clone = node_object.clone()
        node_object_clone.setExpanded(expanded)
        group_object.insertChildNode(pos, node_object_clone)

        parent = node_object.parent()
        parent.removeChildNode(node_object)

        return (node_object_clone, group_object)

    def get_renderer(self, fill_symbol):
        """
        Get a QGIS renderer to add symbology to a QGIS-layer
        """
        # to get all properties of symbol:
        # print(layer.renderer().symbol().symbolLayers()[0].properties())
        # see: https://opensourceoptions.com/loading-and-symbolizing-vector-layers
        if isinstance(fill_symbol, str):
            fill_symbol = QgsStyle.defaultStyle().symbol(fill_symbol)
        if fill_symbol is None:
            fill_symbol = QgsFillSymbol([QgsSimpleLineSymbolLayer.create()])
        if isinstance(fill_symbol, QgsFillSymbol):
            return QgsSingleSymbolRenderer(fill_symbol.clone()).clone()
        return None

    def get_layer_by_name(self, layer_name):
        """
        Get the layer-object based on the layername
        """
        layers = QgsProject.instance().mapLayersByName(layer_name)
        return layers[0]

    def write_geojson(self, path_to_file, geojson):
        """
        Write a GeoJSON object to a file.

        Args:
            path_to_file (str): Path to the output file.
            geojson (FeatureCollection): The GeoJSON object to write.
        """
        parent = os.path.dirname(path_to_file)
        os.makedirs(parent, exist_ok=True)
        with open(path_to_file, "w") as f:
            dump(geojson, f, default=str)

# from qgis.gui import QgsMapToolIdentifyFeature, QgsMapToolIdentify
# from qgis.core import (
#     Qgis, QgsVectorLayer
# )
# class selectTool(QgsMapToolIdentifyFeature):
#
#     def __init__(self, iface, layer):
#         self.iface = iface
#         self.canvas = self.iface.mapCanvas()
#         self.layer = layer
#         QgsMapToolIdentifyFeature.__init__(self, self.canvas, self.layer)
#         self.iface.currentLayerChanged.connect(self.active_changed)
#
#     def active_changed(self, layer):
#         self.layer.removeSelection()
#         if isinstance(layer, QgsVectorLayer) and layer.isSpatial():
#             self.layer = layer
#             self.setLayer(self.layer)
#
#     def canvasPressEvent(self, event):
#         found_features = self.identify(event.x(), event.y(), [self.layer], QgsMapToolIdentify.TopDownAll)
#         print(found_features)
#         self.layer.selectByIds([f.mFeature.id() for f in found_features], QgsVectorLayer.AddToSelection)
#
#     def deactivate(self):
#         self.layer.removeSelection()
