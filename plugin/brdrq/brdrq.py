# -*- coding: utf-8 -*-

"""
/***************************************************************************
 BrdrQ
                                 A QGIS plugin
 brdrQ, a QGIS-plugin for aligning thematic borders to reference borders.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-10-11
        copyright            : (C) 2024 by Karel Dieussaert / Onroerend Erfgoed
        email                : karel.dieussaert@vlaanderen.be
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = "Karel Dieussaert / Onroerend Erfgoed"
__date__ = "2024-10-11"
__copyright__ = "(C) 2024 by Karel Dieussaert / Onroerend Erfgoed"

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = "$Format:%H$"

import inspect
import os
import sys

import numpy as np
from PyQt5.QtGui import QIcon
from PyQt5.QtWidgets import QAction, QListWidgetItem
from qgis import processing
from qgis.PyQt.QtCore import QCoreApplication
from qgis.PyQt.QtCore import Qt
from qgis.core import QgsApplication
from qgis.core import QgsMapLayerProxyModel
from qgis.core import QgsProject
from qgis.core import QgsSettings
from qgis.core import QgsStyle
from qgis.utils import OverrideCursor
from shapely.io import from_wkt

from .brdrq_dockwidget import brdrQDockWidget
from .brdrq_help import brdrQHelp
from .brdrq_provider import BrdrQProvider
from .brdrq_settings import brdrQSettings
from .brdrq_utils import (
    plot_series,
    show_map,
    geom_shapely_to_qgis,
    ENUM_REFERENCE_OPTIONS,
    geojson_to_layer,
    ADPF_VERSIONS,
    geom_qgis_to_shapely,
    GRB_TYPES,
    get_layer_by_name,
    get_workfolder, ENUM_SNAP_STRATEGY_OPTIONS, ENUM_OD_STRATEGY_OPTIONS,
)

cmd_folder = os.path.split(inspect.getfile(inspect.currentframe()))[0]

if cmd_folder not in sys.path:
    sys.path.insert(0, cmd_folder)

from brdr.aligner import Aligner
from brdr.grb import GRBActualLoader, GRBFiscalParcelLoader
from brdr.enums import GRBType, AlignerResultType, OpenbaarDomeinStrategy, SnapStrategy
from brdr.loader import DictLoader


class BrdrQPlugin(object):

    def __init__(self, iface):
        print ("init")
        self.provider = None
        self.iface = iface
        self.dockwidget = None
        self.pluginIsActive = False
        self.actions = []
        self.toolbar = self.iface.addToolBar("brdrQ")
        self.toolbar.setObjectName("brdrQ")
        self.max_rel_dist = None
        self.minimum = 0
        self.maximum = 1500
        self.step = 10
        self.relevant_distances = None
        self.max_feature_count = 5000
        self.max_area_optimization = 100000
        self.max_area_limit = 400000 #maximum mÂ² where the calculation will be done for
        self.layer = None
        self.selected_features = None
        self.feature = None
        self.dict_series = None
        self.dict_predictions = None
        self.diffs_dict = None
        self.aligner = None
        self.od_strategy = None
        self.threshold_overlap_percentage = None
        self.reference_choice = None
        self.reference_layer = None
        self.reference_id = None
        self.reference_loader = None
        self.original_geometry = None
        self.formula = None
        self.full_parcel = None
        self.partial_snapping =None
        self.partial_snapping_strategy =None
        self.snap_max_segment_length=None
        self.GROUP_LAYER = "brdrQ_plugin"
        self.LAYER_RESULT = (
            "RESULT"  # parameter that holds the TOC layername of the result
        )
        self.LAYER_RESULT_DIFF = (
            "DIFF"  # parameter that holds the TOC layername of the resulting diff
        )
        self.LAYER_RESULT_DIFF_PLUS = "DIFF_PLUS"  # parameter that holds the TOC layername of the resulting diff_plus
        self.LAYER_RESULT_DIFF_MIN = "DIFF_MIN"  # parameter that holds the TOC layername of the resulting diff_min
        self.helpDialog = brdrQHelp()
        self.settingsDialog = brdrQSettings()
        self.tempfolder = get_workfolder("", "brdrQ", temporary=True)

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate("brdrQ", message)

    def initProcessing(self):
        """Init Processing provider for QGIS >= 3.8."""

        self.provider = BrdrQProvider()
        QgsApplication.processingRegistry().addProvider(self.provider)

    def initGui(self):
        #print ("initGui")
        self.initProcessing()
        icon = os.path.join(os.path.join(cmd_folder, "icon.png"))
        action_featurepredictor = QAction(
            QIcon(icon), "brdrQ - GRB actual Parcel Aligner", self.iface.mainWindow()
        )
        action_featurepredictor.triggered.connect(self.openDock)
        self.iface.addPluginToMenu("brdQ", action_featurepredictor)
        self.toolbar.addAction(action_featurepredictor)
        self.actions.append(action_featurepredictor)
        icon_autocorrectborders = os.path.join(os.path.join(cmd_folder, "icon_autocorrectborders.png"))
        action_autocorrectborders = QAction(
            QIcon(icon_autocorrectborders), "Autocorrectborders", self.iface.mainWindow()
        )
        action_autocorrectborders.triggered.connect(self.openAutocorrectbordersscript)
        # self.iface.addToolBarIcon(action)
        self.iface.addPluginToMenu("brdQ", action_autocorrectborders)
        self.toolbar.addAction(action_autocorrectborders)
        self.actions.append(action_autocorrectborders)

        # show the dockwidget
        #self.openDock()
        self.load_settings()

    def load_settings(self):
        #print("load settings")
        for r in ENUM_REFERENCE_OPTIONS:
            self.settingsDialog.comboBox_referencelayer.addItem(r)
        for od in ENUM_OD_STRATEGY_OPTIONS:
            self.settingsDialog.comboBox_odstrategy.addItem(od)
        for s in ENUM_SNAP_STRATEGY_OPTIONS:
            self.settingsDialog.comboBox_snapstrategy.addItem(s)
        self.settingsDialog.comboBox_referencelayer.currentIndexChanged.connect(
            self.update_reference_choice
        )
        self.settingsDialog.checkBox_partial_snapping.stateChanged.connect(
            self.update_partial_snapping
        )
        self.settingsDialog.mMapLayerComboBox_reference.layerChanged.connect(
            self.updateFields_reference
        )
        self.settingsDialog.buttonBox_settings.accepted.connect(self.push_settings_ok)

        # Load initial settings into tool (same as pushing OK in settings Dialog)
        self._update_settings()
        return

    def update_reference_choice(self, index):
        #print(str(index))
        if index == 0:
            self.settingsDialog.mMapLayerComboBox_reference.setEnabled(True)
            self.settingsDialog.mFieldComboBox_reference.setEnabled(True)
        else:
            self.settingsDialog.mMapLayerComboBox_reference.setEnabled(False)
            self.settingsDialog.mFieldComboBox_reference.setEnabled(False)
        return

    def update_partial_snapping(self, state):
        if state==2:
            self.settingsDialog.comboBox_snapstrategy.setEnabled(True)
            self.settingsDialog.spinBox_snap_max_segment_length.setEnabled(True)
        else:
            self.settingsDialog.comboBox_snapstrategy.setEnabled(False)
            self.settingsDialog.spinBox_snap_max_segment_length.setEnabled(False)
        return

    def updateFields_reference(self):
        layer = self.settingsDialog.mMapLayerComboBox_reference.currentLayer()
        self.settingsDialog.mFieldComboBox_reference.setLayer(layer)

    def push_settings_ok(self):
        print("push settings ok")
        self._update_settings()
        # self.dockwidget.listWidget_features.clearSelection()
        self.dockwidget.listWidget_predictions.clear()
        self.dockwidget.textEdit_output.setText("Please select a feature to align")
        self.remove_brdrq_layers()
        self.feature=None

    def _update_settings(self):
        s = QgsSettings()
        if self.threshold_overlap_percentage is None:
            self.threshold_overlap_percentage = int(s.value("brdrq/threshold_overlap_percentage", 50))
            self.settingsDialog.spinBox_threshold.setValue(self.threshold_overlap_percentage)
        self.threshold_overlap_percentage = (
            self.settingsDialog.spinBox_threshold.value()
        )
        if self.max_rel_dist is None:
            self.max_rel_dist = int(s.value("brdrq/max_rel_dist", 5))
            self.settingsDialog.spinBox_max_relevant_distance.setValue(self.max_rel_dist)
        self.max_rel_dist = (
            self.settingsDialog.spinBox_max_relevant_distance.value()
        )
        self.maximum = self.max_rel_dist*100

        self.relevant_distances = [
            round(k, 1)
            for k in np.arange(
                self.minimum, self.maximum + self.step, self.step, dtype=int
            )
            / 100
        ]
        if not self.dockwidget is None:
            self.dockwidget.doubleSpinBox.setMinimum(self.minimum / 100)
            self.dockwidget.doubleSpinBox.setMaximum(self.maximum / 100)
            self.dockwidget.doubleSpinBox.setSingleStep(self.step / 100)
            self.dockwidget.doubleSpinBox.setDecimals(1)
            self.dockwidget.doubleSpinBox.setValue(0.0)
            self.dockwidget.horizontalSlider.setMinimum(0)
            self.dockwidget.horizontalSlider.setMaximum(len(self.relevant_distances)-1)
            self.dockwidget.horizontalSlider.setSingleStep(1)


        if self.od_strategy is None:
            self.od_strategy = int(s.value("brdrq/od_strategy", 2))
            index = self.settingsDialog.comboBox_odstrategy.findText(OpenbaarDomeinStrategy(self.od_strategy).name)
            self.settingsDialog.comboBox_odstrategy.setCurrentIndex(index)
        self.od_strategy = OpenbaarDomeinStrategy[
            self.settingsDialog.comboBox_odstrategy.currentText()
        ].value
        if self.partial_snapping_strategy is None or self.partial_snapping_strategy == "":
            no_pref = SnapStrategy.NO_PREFERENCE.name
            self.partial_snapping_strategy = s.value("brdrq/partial_snapping_strategy", no_pref)
            index = self.settingsDialog.comboBox_snapstrategy.findText(self.partial_snapping_strategy)
            if index == -1:
                index=0
            self.settingsDialog.comboBox_snapstrategy.setCurrentIndex(index)
        self.partial_snapping_strategy =SnapStrategy[self.settingsDialog.comboBox_snapstrategy.currentText()]

        if self.reference_choice is None:
            self.reference_choice = s.value("brdrq/reference_choice", ENUM_REFERENCE_OPTIONS[1])
            index = self.settingsDialog.comboBox_referencelayer.findText(self.reference_choice)
            self.settingsDialog.comboBox_referencelayer.setCurrentIndex(index)
        self.reference_choice = (
            self.settingsDialog.comboBox_referencelayer.currentText()
        )
        current_reference_layer_index = self.settingsDialog.mMapLayerComboBox_reference.currentIndex()
        if current_reference_layer_index ==-1 or current_reference_layer_index ==0:
            self.reference_layer =s.value("brdrq/reference_layer", None)
            self.settingsDialog.mMapLayerComboBox_reference.setLayer(self.reference_layer)
        self.reference_layer =self.settingsDialog.mMapLayerComboBox_reference.currentLayer()

        current_reference_id_index = self.settingsDialog.mFieldComboBox_reference.currentIndex()
        if current_reference_id_index ==-1 or current_reference_id_index ==0:
            self.reference_id =s.value("brdrq/reference_id", None)
            self.settingsDialog.mFieldComboBox_reference.setField(self.reference_id)
        self.reference_id = (
            self.settingsDialog.mFieldComboBox_reference.currentField()
        )
        if self.full_parcel is None:
            self.full_parcel = int(s.value("brdrq/full_parcel", 0))
            self.settingsDialog.checkBox_full_parcel.setCheckState(self.full_parcel)
        self.full_parcel = (
            self.settingsDialog.checkBox_full_parcel.checkState()
        )

        if self.formula is None:
            self.formula = int(s.value("brdrq/formula", 0))
            self.settingsDialog.checkBox_formula.setCheckState(self.formula)
        self.formula = (
            self.settingsDialog.checkBox_formula.checkState()
        )

        if self.partial_snapping is None:
            self.partial_snapping = int(s.value("brdrq/partial_snapping", 0))
            self.settingsDialog.checkBox_partial_snapping.setCheckState(self.partial_snapping)
        self.partial_snapping = (
            self.settingsDialog.checkBox_partial_snapping.checkState()
        )

        if self.snap_max_segment_length is None:
            self.snap_max_segment_length = int(s.value("brdrq/snap_max_segment_length", 2))
            self.settingsDialog.spinBox_snap_max_segment_length.setValue(self.snap_max_segment_length)
        self.snap_max_segment_length = (
            self.settingsDialog.spinBox_snap_max_segment_length.value()
        )

        print(
            f"settings updated: Reference choice={self.reference_choice} - od_strategy={self.od_strategy} - threshold overlap percenatge = {str(self.threshold_overlap_percentage)}"
        )

        self.aligner = None
        self.aligner = Aligner(
            od_strategy=self.od_strategy,
            threshold_overlap_percentage=self.threshold_overlap_percentage,
            partial_snapping=self.partial_snapping,
            partial_snapping_strategy=self.partial_snapping_strategy,
            snapping_max_segment_length=self.snap_max_segment_length
        )
        #write settings
        s.setValue("brdrq/threshold_overlap_percentage",  self.threshold_overlap_percentage)
        s.setValue("brdrq/od_strategy", self.od_strategy)
        s.setValue("brdrq/reference_choice", self.reference_choice)
        s.setValue("brdrq/reference_id", self.reference_id)
        s.setValue("brdrq/reference_layer", self.reference_layer)
        s.setValue("brdrq/max_rel_dist", self.max_rel_dist)
        s.setValue("brdrq/formula", self.formula)
        s.setValue("brdrq/full_parcel", self.full_parcel)
        s.setValue("brdrq/partial_snapping", self.partial_snapping)
        s.setValue("brdrq/partial_snapping_strategy", self.partial_snapping_strategy.name)
        s.setValue("brdrq/snap_max_segment_length", self.snap_max_segment_length)
        return

    def openAutocorrectbordersscript(self):
        dialog_autocorrectborders = processing.createAlgorithmDialog(
            'brdrqprovider:brdrqautocorrectborders'
        )
        dialog_autocorrectborders.exec()

    def remove_brdrq_layers(self):
        tree = QgsProject.instance().layerTreeRoot()
        node_object = tree.findGroup(self.GROUP_LAYER)
        tree.removeChildNode(node_object)

    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""
        pass
        # print "** CLOSING brdrQ"
        self.remove_brdrq_layers()

        # disconnects
        self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)

        # remove this statement if dockwidget is to remain
        # for reuse if plugin is reopened
        # Commented next statement since it causes QGIS crashe
        # when closing the docked window:
        # self.dockwidget = None

        self.pluginIsActive = False

    def unload(self):
        QgsApplication.processingRegistry().removeProvider(self.provider)
        for action in self.actions:
            self.iface.removeToolBarIcon(action)
            self.toolbar.removeAction(action)
            self.iface.removePluginMenu("brdQ", action)
            del action
        # remove the toolbar
        del self.toolbar

    def openDock(self):
        print("openDock")
        if not self.pluginIsActive:
            self.pluginIsActive = True

            # print "** STARTING brdrQ"

            # dockwidget may not exist if:
            #    first run of plugin
            #    removed on close (see self.onClosePlugin method)
            if self.dockwidget == None:
                # Create the dockwidget (after translation) and keep reference
                self.dockwidget = brdrQDockWidget()

            # connect to provide cleanup on closing of dockwidget
            self.dockwidget.closingPlugin.connect(self.onClosePlugin)
            self.dockwidget.pushButton_help.clicked.connect(self.show_help_dialog)
            self.dockwidget.pushButton_settings.clicked.connect(
                self.show_settings_dialog
            )
            self.dockwidget.pushButton_grafiek.clicked.connect(self.get_graphic)
            self.dockwidget.pushButton_visualisatie.clicked.connect(
                self.get_visualisation
            )
            self.dockwidget.pushButton_save.clicked.connect(self.change_geometry)
            self.dockwidget.pushButton_reset.clicked.connect(self.reset_geometry)
            # self.dockwidget.pushButton_select.clicked.connect(self.start_line_edit)
            self.dockwidget.pushButton_wkt.clicked.connect(self.get_wkt)
            self.dockwidget.mMapLayerComboBox.setFilters(
                QgsMapLayerProxyModel.PolygonLayer
            )
            self.dockwidget.mMapLayerComboBox.layerChanged.connect(self.setFeatures)
            self.dockwidget.listWidget_features.itemPressed.connect(
                self.onFeatureActivated
            )
            self.dockwidget.listWidget_predictions.itemPressed.connect(
                self.onListItemActivated
            )
            self.dockwidget.horizontalSlider.sliderMoved.connect(self.onSliderChange)
            self.dockwidget.doubleSpinBox.valueChanged.connect(self.onSpinboxChange)

            # show the dockwidget
            self.iface.addDockWidget(Qt.RightDockWidgetArea, self.dockwidget)
            # self.dockwidget.show()
            self.layer = self.dockwidget.mMapLayerComboBox.currentLayer()
            self._update_settings()

    def show_help_dialog(self):
        self.helpDialog.show()

    def show_settings_dialog(self):
        self.settingsDialog.show()

    # def setIds(self):
    #     picker = self.dockwidget.mFeaturePickerWidget
    #     layer = self.dockwidget.mMapLayerComboBox.currentLayer()
    #     picker.setLayer(layer)
    #     picker.setDisplayExpression('$id')  # show ids in combobox

    def setFeatures(self):
        self.dockwidget.progressBar.setValue(0)
        self.layer = self.dockwidget.mMapLayerComboBox.currentLayer()
        if self.layer is None:
            self.dockwidget.textEdit_output.setText("Please select a layer")
            return
        if self.layer.selectedFeatureCount() > self.max_feature_count or (
            self.layer.selectedFeatureCount() == 0
            and self.layer.featureCount() > self.max_feature_count
        ):
            self.dockwidget.textEdit_output.setText(
                f"Nr of features bigger than {str(self.max_feature_count)}. Please make a smaller selection of features"
            )
            return
        self.selected_features = [f for f in self.layer.getSelectedFeatures()]
        if self.layer.selectedFeatureCount() == 0:
            self.selected_features = [f for f in self.layer.getFeatures()]
            self.dockwidget.textEdit_output.setText(
                "No selected features in this layer, all features returned"
            )

        # Clear the list widget
        self.dockwidget.listWidget_features.clear()

        # Add the selected features to the list widget
        for feature in self.selected_features:
            attributes = feature.attributes()
            attribute_string = ", ".join(str(attribute) for attribute in attributes)
            item = QListWidgetItem(
                f"ID: *{feature.id()}*, Attributes: {attribute_string}"
            )
            self.dockwidget.listWidget_features.addItem(item)
        self.dockwidget.textEdit_output.setText(
            f"#Features: {str(len(self.selected_features))}"
        )
        return

    def onFeatureActivated(self, currentItem):
        self.dockwidget.progressBar.setValue(0)
        self.dockwidget.listWidget_predictions.clear()
        self.dockwidget.textEdit_output.setText("")
        with OverrideCursor(Qt.WaitCursor):
            self._onFeatureChange(currentItem)
        self.dockwidget.progressBar.setValue(100)

    def _onFeatureChange(self, currentItem):
        print("_onFeatureChange")
        self.feature = None
        if currentItem is None:
            print("currentItem is none")
            return
        feature_id = currentItem.text().split("*")[1]
        # print(f"Feature_id is {feature_id}")
        for feat in self.selected_features:
            # print(str(feat.id()))
            if str(feat.id()) == feature_id:
                # print("equal - >break")
                self.feature = feat
                break
        # print(self.feature)
        if self.feature is None:
            self.dockwidget.textEdit_output.setText(
                f"No feature found with ID {feature_id}"
            )
            return

        # zoom to feature
        self.original_geometry = self.feature.geometry()
        box = self.feature.geometry().boundingBox()
        self.iface.mapCanvas().setExtent(box)
        self.iface.mapCanvas().refresh()
        key = self.feature.id()

        # Check feature on area
        # check area of feature and optimize/block calculation
        area = self.original_geometry.area()
        self.step = 10
        if area > self.max_area_optimization:
            if area > self.max_area_limit:
                msg = f"Very big area, {str(area)} mÂ²: The calculation is blocked. Please use the bulk tool for this feature"
                self.dockwidget.textEdit_output.setText(
                    f"{msg}"
                )
                # self.iface.messageBar().pushMessage(msg)
                return
            else:
                msg = f"Warning - Big area, {str(area)} mÂ²: the calculation will be adapted/optimized. Only for every meter a calculation will be done"
                self.dockwidget.textEdit_output.setText(
                    f"{msg}"
                )
                # self.iface.messageBar().pushMessage(msg)
                self.step = 100

        self._update_settings()

        # do alignment/prediction
        self._align()

        fcs = self.aligner.get_results_as_geojson(
            resulttype=AlignerResultType.PROCESSRESULTS,
            formula=self.formula
        )

        geojson_to_layer(
            self.LAYER_RESULT_DIFF,
            fcs["result_diff"],
            QgsStyle.defaultStyle().symbol("hashed black X"),
            False,
            self.GROUP_LAYER,
            self.tempfolder,
        )
        geojson_to_layer(
            self.LAYER_RESULT_DIFF_PLUS,
            fcs["result_diff_plus"],
            QgsStyle.defaultStyle().symbol("hashed cgreen /"),
            True,
            self.GROUP_LAYER,
            self.tempfolder,
        )
        geojson_to_layer(
            self.LAYER_RESULT_DIFF_MIN,
            fcs["result_diff_min"],
            QgsStyle.defaultStyle().symbol("hashed cred /"),
            True,
            self.GROUP_LAYER,
            self.tempfolder,
        )
        geojson_to_layer(
            self.LAYER_RESULT,
            fcs["result"],
            QgsStyle.defaultStyle().symbol("outline green"),
            True,
            self.GROUP_LAYER,
            self.tempfolder,
        )

        # set list with predicted values
        self.dockwidget.listWidget_predictions.clear()
        items = [str(k) for k in self.dict_predictions[key]]
        self.dockwidget.listWidget_predictions.addItems(items)
        if len(items) > 1:
            self.dockwidget.listWidget_predictions.setCurrentRow(1)
            self.dockwidget.doubleSpinBox.setValue(round(float(items[1]), 1))
        elif len(items) > 0:
            self.dockwidget.listWidget_predictions.setCurrentRow(0)
            self.dockwidget.doubleSpinBox.setValue(round(float(items[0]), 1))
        else:
            self.dockwidget.textEdit_output.setText("No predictions")

    def onListItemActivated(self, currentItem):
        print("onListItemActivated")
        self._listItemActivated(currentItem)

    def _listItemActivated(self, currentItem):

        if currentItem is None:
            print("currentitem zero")
            return
        print("item activated with rd: " + currentItem.text())
        value = round(float(currentItem.text()), 1)
        print("item activated with rd - value: " + str(value))
        self.dockwidget.doubleSpinBox.setValue(value)
        index = self.relevant_distances.index(value)
        self.dockwidget.horizontalSlider.setValue(index)
        return

    def onSliderChange(self, index):
        print("onSliderChange: index -> " + str(index))
        value = self.relevant_distances[index]
        self.dockwidget.doubleSpinBox.setValue(value)
        return

    def onSpinboxChange(self, value):
        value = round(value, 1)
        index = self.relevant_distances.index(value)
        self.dockwidget.horizontalSlider.setValue(index)
        print("onSpinboxChange: value -> " + str(value))

        # self.change_geometry()
        # Filter layers based on relevant distance
        get_layer_by_name(self.LAYER_RESULT).setSubsetString(
            f"brdr_relevant_distance = {value}"
        )
        get_layer_by_name(self.LAYER_RESULT_DIFF).setSubsetString(
            f"brdr_relevant_distance = {value}"
        )
        get_layer_by_name(self.LAYER_RESULT_DIFF_MIN).setSubsetString(
            f"brdr_relevant_distance = {value}"
        )
        get_layer_by_name(self.LAYER_RESULT_DIFF_PLUS).setSubsetString(
            f"brdr_relevant_distance = {value}"
        )
        return

    # def start_line_edit(self):
    #     print("button pushed")
    #     self.t = selectTool(self.iface, self.dockwidget.mMapLayerComboBox.currentLayer())
    #     self.iface.mapCanvas().setMapTool(self.t)

    def get_graphic(self):
        # feat = self.dockwidget.mFeaturePickerWidget.feature()
        feat = self.feature
        if feat is None:
            return
        key = feat.id()
        plot_series(self.relevant_distances, {key: self.diffs_dict[key]})
        return

    def get_visualisation(self):
        # feat = self.dockwidget.mFeaturePickerWidget.feature()
        feat = self.feature
        if feat is None:
            return
        key = feat.id()
        show_map(
            {key: self.dict_predictions[key]},
            {key: self.aligner.dict_thematic[key]},
            self.aligner.dict_reference,
        )
        return

    def change_geometry(self):
        # feat = self.dockwidget.mFeaturePickerWidget.feature()
        feat = self.feature
        if feat is None:
            return
        key = feat.id()
        relevant_distance = self.dockwidget.doubleSpinBox.value()
        if relevant_distance in self.dict_series[key]:
            result = self.dict_series[key][relevant_distance]
            resulting_geom = result["result"]
        else:
            errormesssage = "Relevant_distance_result not calculated for: " + str(
                relevant_distance
            )
            self.iface.messageBar().pushMessage(errormesssage)
            print(errormesssage)
            return
        # layer = self.dockwidget.mMapLayerComboBox.currentLayer()
        layer = self.layer
        layer.startEditing()
        qgis_geom = geom_shapely_to_qgis(resulting_geom)
        layer.changeGeometry(feat.id(), qgis_geom)
        layer.commitChanges()
        self.iface.messageBar().pushMessage("geometrie aangepast")

    def reset_geometry(self):
        # feat = self.dockwidget.mFeaturePickerWidget.feature()
        feat = self.feature
        if feat is None:
            return
        # layer = self.dockwidget.mMapLayerComboBox.currentLayer()
        layer = self.layer
        layer.startEditing()
        layer.changeGeometry(feat.id(), self.original_geometry)
        layer.commitChanges()
        self.iface.messageBar().pushMessage("geometrie gereset")

    def get_wkt(self):
        # feat = self.dockwidget.mFeaturePickerWidget.feature()
        feat = self.feature
        if feat is None:
            return
        key = feat.id()
        relevant_distance = self.dockwidget.doubleSpinBox.value()
        if relevant_distance in self.dict_series[key]:
            result = self.dict_series[key][relevant_distance]
            resulting_geom = result["result"]
        else:
            errormesssage = "Relevant_distance_result not calculated for: " + str(
                relevant_distance
            )
            self.iface.messageBar().pushMessage(errormesssage)
            self.dockwidget.textEdit_output.setText(errormesssage)
            return
        wkt = resulting_geom.wkt
        self.dockwidget.textEdit_output.setText(wkt)

    def _align(self):
        # feat = self.dockwidget.mFeaturePickerWidget.feature()
        feat = self.feature
        selectedFeatures = []
        if feat is not None:
            selectedFeatures.append(feat)
        if len(selectedFeatures) == 0:
            self.dockwidget.textEdit_output.setText(
                "Geen features geselecteerd. Gelieve een feature te selecteren uit de actieve laag"
            )
            return

        dict_to_load = {}

        self.dockwidget.progressBar.setValue(0)
        for feature in selectedFeatures:
            feature_geom = feature.geometry()
            wkt = feature_geom.asWkt()
            geom_shapely = from_wkt(wkt)
            dict_to_load[feature.id()] = geom_shapely

        # Load thematic data
        self.aligner.load_thematic_data(DictLoader(dict_to_load))
        self.dockwidget.progressBar.setValue(25)
        # Load reference data for the on-the fly reference versions
        print(self.reference_choice)
        if self.reference_choice in GRB_TYPES:
            self.aligner.load_reference_data(
                GRBActualLoader(
                    grb_type=GRBType[self.reference_choice],
                    partition=1000,
                    aligner=self.aligner,
                )
            )
            print("grbtype")
        elif self.reference_choice in ADPF_VERSIONS:
            year = self.reference_choice.removeprefix("Adpf")
            self.aligner.load_reference_data(
                GRBFiscalParcelLoader(year=year, aligner=self.aligner, partition=1000)
            )
            print("adpftype")
        else:
            print("localtype")
            # Load reference into a shapely_dict:
            dict_reference = {}
            processing.run(
                "native:selectwithindistance",
                {
                    "INPUT": self.reference_layer,
                    "REFERENCE": self.layer,
                    "DISTANCE": 2 * self.maximum / 100,
                    "METHOD": 0,
                },
            )
            features = self.reference_layer.selectedFeatures()
            for current, feature in enumerate(features):
                id_reference = feature.attribute(self.reference_id)
                dict_reference[id_reference] = geom_qgis_to_shapely(feature.geometry())
            self.reference_layer.removeSelection()
            self.aligner.load_reference_data(DictLoader(dict_reference))
            self.aligner.name_reference_id = self.reference_id
            self.aligner.dict_reference_source["source"] = "local"
            self.aligner.dict_reference_source["version_date"] = "unknown"
        self.dockwidget.progressBar.setValue(50)
        self.dict_series, self.dict_predictions, self.diffs_dict = (
            self.aligner.predictor(
                relevant_distances=self.relevant_distances,
                od_strategy=self.od_strategy,
                threshold_overlap_percentage=self.threshold_overlap_percentage,
            )
        )
        outputMessage = "Voorspelde relevante afstanden: " + str(
            [str(k) for k in self.dict_predictions[feat.id()].keys()]
        )
        self.dockwidget.textEdit_output.setText(outputMessage)
        self.iface.messageBar().pushMessage(outputMessage)
        #self.dockwidget.progressBar.setValue(100)
        return self.dict_series, self.dict_predictions, self.diffs_dict

# from qgis.gui import QgsMapToolIdentifyFeature, QgsMapToolIdentify
# from qgis.core import (
#     Qgis, QgsVectorLayer
# )
# class selectTool(QgsMapToolIdentifyFeature):
#
#     def __init__(self, iface, layer):
#         self.iface = iface
#         self.canvas = self.iface.mapCanvas()
#         self.layer = layer
#         QgsMapToolIdentifyFeature.__init__(self, self.canvas, self.layer)
#         self.iface.currentLayerChanged.connect(self.active_changed)
#
#     def active_changed(self, layer):
#         self.layer.removeSelection()
#         if isinstance(layer, QgsVectorLayer) and layer.isSpatial():
#             self.layer = layer
#             self.setLayer(self.layer)
#
#     def canvasPressEvent(self, event):
#         found_features = self.identify(event.x(), event.y(), [self.layer], QgsMapToolIdentify.TopDownAll)
#         print(found_features)
#         self.layer.selectByIds([f.mFeature.id() for f in found_features], QgsVectorLayer.AddToSelection)
#
#     def deactivate(self):
#         self.layer.removeSelection()