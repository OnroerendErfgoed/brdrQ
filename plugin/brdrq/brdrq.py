# -*- coding: utf-8 -*-

"""
/***************************************************************************
 BrdrQ
                                 A QGIS plugin
 brdrQ, a QGIS-plugin for aligning thematic borders to reference borders.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-10-11
        copyright            : (C) 2024 by Karel Dieussaert / Onroerend Erfgoed
        email                : karel.dieussaert@vlaanderen.be
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = "Karel Dieussaert / Onroerend Erfgoed"
__date__ = "2024-10-11"
__copyright__ = "(C) 2024 by Karel Dieussaert / Onroerend Erfgoed"

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = "$Format:%H$"

import inspect
import os
import sys

import brdr
import numpy as np
from PyQt5.QtCore import pyqtSignal
from PyQt5.QtGui import QIcon
from PyQt5.QtWidgets import QAction, QListWidgetItem
from brdr.constants import PREDICTION_SCORE, EVALUATION_FIELD_NAME
from qgis import processing
from qgis.PyQt.QtCore import QCoreApplication
from qgis.PyQt.QtCore import Qt
from qgis.core import QgsApplication
from qgis.core import QgsProject
from qgis.core import QgsSettings
from qgis.core import QgsStyle
from qgis.gui import QgsMapToolPan
from qgis.utils import OverrideCursor
from shapely.io import from_wkt

from .brdrq_dockwidget import brdrQDockWidget
from .brdrq_dockwidget_bulkaligner import brdrQDockWidgetBulkAligner
from .brdrq_help import brdrQHelp
from .brdrq_provider import BrdrQProvider
from .brdrq_settings import brdrQSettings
from .brdrq_utils import (
    plot_series,
    show_map,
    geom_shapely_to_qgis,
    ENUM_REFERENCE_OPTIONS,
    geojson_to_layer,
    ADPF_VERSIONS,
    geom_qgis_to_shapely,
    GRB_TYPES,
    get_layer_by_name,
    get_workfolder,
    ENUM_SNAP_STRATEGY_OPTIONS,
    ENUM_OD_STRATEGY_OPTIONS,
)

cmd_folder = os.path.split(inspect.getfile(inspect.currentframe()))[0]

if cmd_folder not in sys.path:
    sys.path.insert(0, cmd_folder)

from brdr.aligner import Aligner
from brdr.grb import GRBActualLoader, GRBFiscalParcelLoader
from brdr.enums import GRBType, AlignerResultType, OpenbaarDomeinStrategy, SnapStrategy
from brdr.loader import DictLoader
from brdr.utils import diffs_from_dict_processresults


class BrdrQPlugin(object):

    def __init__(self, iface):
        print("init")
        self.provider = None
        self.iface = iface
        self.dockwidget = None
        self.dockwidget_bulkaligner = None
        self.actions = []
        self.toolbar = self.iface.addToolBar("brdrQ")
        self.toolbar.setObjectName("brdrQ")
        self.formerMapTool = None
        self.max_rel_dist = None
        self.minimum = 0
        self.maximum = 1500
        self.step = 10
        self.relevant_distances = None
        self.max_feature_count = 5000
        self.max_area_optimization = 100000
        self.max_area_limit = (
            400000  # maximum mÂ² where the calculation will be done for
        )
        self.layer = None
        self.listed_features = None
        self.feature = None
        self.dict_processresults = None
        self.dict_evaluated_predictions = None
        self.props_dict_evaluated_predictions = None
        self.diffs_dict = None
        self.aligner = None
        self.od_strategy = None
        self.threshold_overlap_percentage = None
        self.reference_choice = None
        self.reference_layer = None
        self.reference_id = None
        self.reference_loader = None
        self.original_geometry = None
        self.formula = None
        self.full_parcel = None
        self.partial_snapping = None
        self.partial_snapping_strategy = None
        self.snap_max_segment_length = None
        self.DECIMAL = 1
        self.GROUP_LAYER = "brdrQ_plugin"
        self.LAYER_RESULT = (
            "RESULT"  # parameter that holds the TOC layername of the result
        )
        self.LAYER_RESULT_DIFF = (
            "DIFF"  # parameter that holds the TOC layername of the resulting diff
        )
        self.LAYER_RESULT_DIFF_PLUS = "DIFF_PLUS"  # parameter that holds the TOC layername of the resulting diff_plus
        self.LAYER_RESULT_DIFF_MIN = "DIFF_MIN"  # parameter that holds the TOC layername of the resulting diff_min
        self.helpDialog = brdrQHelp()
        self.settingsDialog = brdrQSettings()
        self.tempfolder = get_workfolder("", "brdrQ", temporary=True)

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate("brdrQ", message)

    def initProcessing(self):
        """Init Processing provider for QGIS >= 3.8."""

        self.provider = BrdrQProvider()
        QgsApplication.processingRegistry().addProvider(self.provider)

    def initGui(self):
        # print ("initGui")
        self.initProcessing()
        icon = os.path.join(os.path.join(cmd_folder, "icon_featurealigner.png"))
        action_featurepredictor = QAction(
            QIcon(icon), "brdrQ - Feature Aligner (predictor)", self.iface.mainWindow()
        )
        action_featurepredictor.triggered.connect(self.openDock)
        self.iface.addPluginToMenu("brdQ", action_featurepredictor)
        self.toolbar.addAction(action_featurepredictor)
        self.actions.append(action_featurepredictor)


        icon_bulkaligner = os.path.join(os.path.join(cmd_folder, "icon_base.png"))
        action_bulkaligner = QAction(
            QIcon(icon_bulkaligner), "brdrQ - Bulk Aligner (predictor)", self.iface.mainWindow()
        )
        action_bulkaligner.triggered.connect(self.openDockBulkAligner)
        self.iface.addPluginToMenu("brdQ", action_bulkaligner)
        self.toolbar.addAction(action_bulkaligner)
        self.actions.append(action_bulkaligner)

        icon_autocorrectborders = os.path.join(
            os.path.join(cmd_folder, "icon_autocorrectborders.png")
        )
        action_autocorrectborders = QAction(
            QIcon(icon_autocorrectborders),
            "Autocorrectborders (bulk)",
            self.iface.mainWindow(),
        )
        action_autocorrectborders.triggered.connect(self.openAutocorrectbordersscript)
        self.iface.addPluginToMenu("brdQ", action_autocorrectborders)
        self.toolbar.addAction(action_autocorrectborders)
        self.actions.append(action_autocorrectborders)

        icon_autoupdateborders = os.path.join(
            os.path.join(cmd_folder, "icon_autoupdateborders.png")
        )
        action_autoupdateborders = QAction(
            QIcon(icon_autoupdateborders),
            "Autoupdateborders (bulk)",
            self.iface.mainWindow(),
        )
        action_autoupdateborders.triggered.connect(self.openAutoupdatebordersscript)
        self.iface.addPluginToMenu("brdQ", action_autoupdateborders)
        self.toolbar.addAction(action_autoupdateborders)
        self.actions.append(action_autoupdateborders)

        icon_info = os.path.join(
            os.path.join(cmd_folder, "icon_info.png")
        )
        action_info = QAction(
            QIcon(icon_info),
            "brdrQ - info (version)",
            self.iface.mainWindow(),
        )
        action_info.triggered.connect(self.openInfo)
        self.iface.addPluginToMenu("brdQ", action_info)
        self.toolbar.addAction(action_info)
        self.actions.append(action_info)

        # show the dockwidget
        # self.openDock()
        self.load_settings()

    def load_settings(self):
        # print("load settings")
        for r in ENUM_REFERENCE_OPTIONS:
            self.settingsDialog.comboBox_referencelayer.addItem(r)
        for od in ENUM_OD_STRATEGY_OPTIONS:
            self.settingsDialog.comboBox_odstrategy.addItem(od)
        for s in ENUM_SNAP_STRATEGY_OPTIONS:
            self.settingsDialog.comboBox_snapstrategy.addItem(s)
        self.settingsDialog.comboBox_referencelayer.currentIndexChanged.connect(
            self.update_reference_choice
        )
        self.settingsDialog.checkBox_partial_snapping.stateChanged.connect(
            self.update_partial_snapping
        )
        self.settingsDialog.mMapLayerComboBox_reference.layerChanged.connect(
            self.updateFields_reference
        )
        self.settingsDialog.buttonBox_settings.accepted.connect(self.push_settings_ok)

        # Load initial settings into tool (same as pushing OK in settings Dialog)
        self.update_settings()
        return

    def update_reference_choice(self, index):
        # print(str(index))
        if index == 0:
            self.settingsDialog.mMapLayerComboBox_reference.setEnabled(True)
            self.settingsDialog.mFieldComboBox_reference.setEnabled(True)
        else:
            self.settingsDialog.mMapLayerComboBox_reference.setEnabled(False)
            self.settingsDialog.mFieldComboBox_reference.setEnabled(False)
        return

    def update_partial_snapping(self, state):
        if state == 2:
            self.settingsDialog.comboBox_snapstrategy.setEnabled(True)
            self.settingsDialog.spinBox_snap_max_segment_length.setEnabled(True)
        else:
            self.settingsDialog.comboBox_snapstrategy.setEnabled(False)
            self.settingsDialog.spinBox_snap_max_segment_length.setEnabled(False)
        return

    # def update_checkBox_only_selected(self, state):
    #     self.listFeatures()
    #     return

    def updateFields_reference(self):
        layer = self.settingsDialog.mMapLayerComboBox_reference.currentLayer()
        self.settingsDialog.mFieldComboBox_reference.setLayer(layer)

    def push_settings_ok(self):
        print("push settings ok")
        self.update_settings()
        # self.dockwidget.listWidget_features.clearSelection()
        self.dockwidget.listWidget_predictions.clear()
        self.dockwidget.textEdit_output.setText("Please select a feature to align")
        self.remove_brdrq_layers()
        self.feature = None

    def update_settings(self):
        s = QgsSettings()
        if self.threshold_overlap_percentage is None:
            self.threshold_overlap_percentage = int(
                s.value("brdrq/threshold_overlap_percentage", 50)
            )
            self.settingsDialog.spinBox_threshold.setValue(
                self.threshold_overlap_percentage
            )
        self.threshold_overlap_percentage = (
            self.settingsDialog.spinBox_threshold.value()
        )
        if self.max_rel_dist is None:
            self.max_rel_dist = int(s.value("brdrq/max_rel_dist", 5))
            self.settingsDialog.spinBox_max_relevant_distance.setValue(
                self.max_rel_dist
            )
        self.max_rel_dist = self.settingsDialog.spinBox_max_relevant_distance.value()
        self.maximum = self.max_rel_dist * 100

        self.relevant_distances = [
            round(k, self.DECIMAL)
            for k in np.arange(
                self.minimum, self.maximum + self.step, self.step, dtype=int
            )
            / 100
        ]
        if not self.dockwidget is None:
            self.dockwidget.doubleSpinBox.setMinimum(self.minimum / 100)
            self.dockwidget.doubleSpinBox.setMaximum(self.maximum / 100)
            self.dockwidget.doubleSpinBox.setSingleStep(self.step / 100)
            self.dockwidget.doubleSpinBox.setDecimals(self.DECIMAL)
            self.dockwidget.doubleSpinBox.setValue(0.0)
            self.dockwidget.horizontalSlider.setMinimum(0)
            self.dockwidget.horizontalSlider.setMaximum(
                len(self.relevant_distances) - 1
            )
            self.dockwidget.horizontalSlider.setSingleStep(1)

        if self.od_strategy is None:
            self.od_strategy = int(s.value("brdrq/od_strategy", 2))
            index = self.settingsDialog.comboBox_odstrategy.findText(
                OpenbaarDomeinStrategy(self.od_strategy).name
            )
            self.settingsDialog.comboBox_odstrategy.setCurrentIndex(index)
        self.od_strategy = OpenbaarDomeinStrategy[
            self.settingsDialog.comboBox_odstrategy.currentText()
        ].value
        if (
            self.partial_snapping_strategy is None
            or self.partial_snapping_strategy == ""
        ):
            no_pref = SnapStrategy.NO_PREFERENCE.name
            self.partial_snapping_strategy = s.value(
                "brdrq/partial_snapping_strategy", no_pref
            )
            index = self.settingsDialog.comboBox_snapstrategy.findText(
                self.partial_snapping_strategy
            )
            if index == -1:
                index = 0
            self.settingsDialog.comboBox_snapstrategy.setCurrentIndex(index)
        self.partial_snapping_strategy = SnapStrategy[
            self.settingsDialog.comboBox_snapstrategy.currentText()
        ]

        if self.reference_choice is None:
            self.reference_choice = s.value(
                "brdrq/reference_choice", ENUM_REFERENCE_OPTIONS[1]
            )
            index = self.settingsDialog.comboBox_referencelayer.findText(
                self.reference_choice
            )
            self.settingsDialog.comboBox_referencelayer.setCurrentIndex(index)
        self.reference_choice = (
            self.settingsDialog.comboBox_referencelayer.currentText()
        )
        current_reference_layer_index = (
            self.settingsDialog.mMapLayerComboBox_reference.currentIndex()
        )
        if current_reference_layer_index == -1 or current_reference_layer_index == 0:
            self.reference_layer = s.value("brdrq/reference_layer", None)
            self.settingsDialog.mMapLayerComboBox_reference.setLayer(
                self.reference_layer
            )
        self.reference_layer = (
            self.settingsDialog.mMapLayerComboBox_reference.currentLayer()
        )

        current_reference_id_index = (
            self.settingsDialog.mFieldComboBox_reference.currentIndex()
        )
        if current_reference_id_index == -1 or current_reference_id_index == 0:
            self.reference_id = s.value("brdrq/reference_id", None)
            self.settingsDialog.mFieldComboBox_reference.setField(self.reference_id)
        self.reference_id = self.settingsDialog.mFieldComboBox_reference.currentField()
        if self.full_parcel is None:
            self.full_parcel = int(s.value("brdrq/full_parcel", 2))
            self.settingsDialog.checkBox_full_parcel.setCheckState(self.full_parcel)
        self.full_parcel = self.settingsDialog.checkBox_full_parcel.checkState()

        if self.formula is None:
            self.formula = int(s.value("brdrq/formula", 0))
            self.settingsDialog.checkBox_formula.setCheckState(self.formula)
        self.formula = self.settingsDialog.checkBox_formula.checkState()

        self.partial_snapping = 0
        if self.partial_snapping is None:
            self.partial_snapping = int(s.value("brdrq/partial_snapping", 0))
            self.settingsDialog.checkBox_partial_snapping.setCheckState(
                self.partial_snapping
            )
        self.partial_snapping = (
            self.settingsDialog.checkBox_partial_snapping.checkState()
        )
        self.partial_snapping = 0

        if self.snap_max_segment_length is None:
            self.snap_max_segment_length = int(
                s.value("brdrq/snap_max_segment_length", 2)
            )
            self.settingsDialog.spinBox_snap_max_segment_length.setValue(
                self.snap_max_segment_length
            )
        self.snap_max_segment_length = (
            self.settingsDialog.spinBox_snap_max_segment_length.value()
        )

        print(
            f"settings updated: Reference choice={self.reference_choice} - od_strategy={self.od_strategy} - threshold overlap percenatge = {str(self.threshold_overlap_percentage)}"
        )
        self.partial_snapping = False
        self.aligner = None
        self.aligner = Aligner(
            od_strategy=self.od_strategy,
            threshold_overlap_percentage=self.threshold_overlap_percentage,
            partial_snapping=self.partial_snapping,
            partial_snapping_strategy=self.partial_snapping_strategy,
            snapping_max_segment_length=self.snap_max_segment_length,
        )
        # write settings
        s.setValue(
            "brdrq/threshold_overlap_percentage", self.threshold_overlap_percentage
        )
        s.setValue("brdrq/od_strategy", self.od_strategy)
        s.setValue("brdrq/reference_choice", self.reference_choice)
        s.setValue("brdrq/reference_id", self.reference_id)
        s.setValue("brdrq/reference_layer", self.reference_layer)
        s.setValue("brdrq/max_rel_dist", self.max_rel_dist)
        s.setValue("brdrq/formula", self.formula)
        s.setValue("brdrq/full_parcel", self.full_parcel)
        s.setValue("brdrq/partial_snapping", self.partial_snapping)
        s.setValue(
            "brdrq/partial_snapping_strategy", self.partial_snapping_strategy.name
        )
        s.setValue("brdrq/snap_max_segment_length", self.snap_max_segment_length)
        return

    def openAutocorrectbordersscript(self):
        dialog_autocorrectborders = processing.createAlgorithmDialog(
            "brdrqprovider:brdrqautocorrectborders"
        )
        dialog_autocorrectborders.exec()

    def openInfo(self):
        msg = f"brdrQ version: {self.version()} - brdr-version: {str(brdr.__version__)}"
        self.iface.messageBar().pushMessage(msg)

    def version(self):
        return "0.9.12"


    def openAutoupdatebordersscript(self):
        dialog_autoupdateborders = processing.createAlgorithmDialog(
            "brdrqprovider:brdrqautoupdateborders"
        )
        dialog_autoupdateborders.exec()

    def remove_brdrq_layers(self):
        tree = QgsProject.instance().layerTreeRoot()
        node_object = tree.findGroup(self.GROUP_LAYER)
        tree.removeChildNode(node_object)

    def unload(self):
        QgsApplication.processingRegistry().removeProvider(self.provider)
        for action in self.actions:
            self.iface.removeToolBarIcon(action)
            self.toolbar.removeAction(action)
            self.iface.removePluginMenu("brdQ", action)
            del action
        # remove the toolbar
        del self.toolbar

    def openDockBulkAligner(self):
        print("openDockBulkAligner")
        print (str(self.dockwidget_bulkaligner))
        if self.dockwidget_bulkaligner is None:
            # Create the dockwidget (after translation) and keep reference
            self.dockwidget_bulkaligner = brdrQDockWidgetBulkAligner(self)
            print("brdrQDockWidgetBulkAligner created")
        print(str(self.dockwidget_bulkaligner.active))
        if not self.dockwidget_bulkaligner.active:
            self.dockwidget_bulkaligner.activate()
        return

    def openDock(self):
        print("openDock")
        if self.dockwidget is None:
            # Create the dockwidget (after translation) and keep reference
            self.dockwidget = brdrQDockWidget(self)
            print("brdrQDockWidget created")
        print(str(self.dockwidget.active))
        if not self.dockwidget.active:
            self.dockwidget.activate()
        return

    def show_help_dialog(self):
        self.helpDialog.show()

    def show_settings_dialog(self):
        self.settingsDialog.show()

    def themeLayerChanged(self):
        #reset interface by clearing list, progress_bar
        self.dockwidget.clearUserInterface()
        self.layer = self.dockwidget.mMapLayerComboBox.currentLayer()
        if self.layer is None:
            self.dockwidget.textEdit_output.setText("Please select a layer")
            return
        if self.layer.selectedFeatureCount() > self.max_feature_count or (
            self.layer.selectedFeatureCount() == 0
            and self.layer.featureCount() > self.max_feature_count
        ):
            self.dockwidget.textEdit_output.setText(
                f"Nr of features bigger than {str(self.max_feature_count)}. Please make a smaller selection of features"
            )
            return

        if self.dockwidget.checkBox_only_selected.checkState()==2:
            self.listed_features = [f for f in self.layer.getSelectedFeatures()]
            self.dockwidget.textEdit_output.setText(
                "Selected features in this layer returned"
            )
        else:
            self.listed_features = [f for f in self.layer.getFeatures()]
            self.dockwidget.textEdit_output.setText(
                "All features in this layer returned"
            )
        self.listFeatures()



    def listFeatures(self):
        self.dockwidget.clearUserInterface()
        # Add the selected features to the list widget
        print ("list features")
        print(str(self.listed_features))
        for feature in self.listed_features:
            attributes = feature.attributes()
            attribute_string = ", ".join(str(attribute) for attribute in attributes)
            item = QListWidgetItem(
                f"ID: *{feature.id()}*, Attributes: {attribute_string}"
            )
            self.dockwidget.listWidget_features.addItem(item)
        self.dockwidget.textEdit_output.setText(
            f"#Features: {str(len(self.listed_features))}"
        )
        if len(self.listed_features) == 1:
            self.onFeatureActivated(self.dockwidget.listWidget_features.item(0))

        return

    def onFeatureActivated(self, currentItem):
        self.dockwidget.deactivateSelectTool()
        self.dockwidget.progressBar.setValue(0)
        self.dockwidget.listWidget_predictions.clear()
        self.dockwidget.textEdit_output.setText("")
        with OverrideCursor(Qt.WaitCursor):
            self._onFeatureChange(currentItem)
        self.dockwidget.progressBar.setValue(100)

    def _onFeatureChange(self, currentItem):
        print("_onFeatureChange")
        self.feature = None
        if currentItem is None:
            print("currentItem is none")
            return
        feature_id = currentItem.text().split("*")[1]
        for feat in self.listed_features:
            if str(feat.id()) == feature_id:
                self.feature = feat
                break
        if self.feature is None:
            self.dockwidget.textEdit_output.setText(
                f"No feature found with ID {feature_id}"
            )
            return

        # zoom to feature
        self.original_geometry = self.feature.geometry()
        box = self.feature.geometry().boundingBox()
        self.iface.mapCanvas().setExtent(box)
        self.iface.mapCanvas().refresh()
        key = self.feature.id()

        # Check feature on area
        # check area of feature and optimize/block calculation
        area = self.original_geometry.area()
        self.step = 10
        if area > self.max_area_optimization:
            if area > self.max_area_limit:
                msg = f"Very big area, {str(area)} mÂ²: The calculation is blocked. Please use the bulk tool for this feature"
                self.dockwidget.textEdit_output.setText(f"{msg}")
                self.dockwidget.doubleSpinBox.setValue(0)
                self.dockwidget.listWidget_predictions.clear()
                return
            else:
                msg = f"Warning - Big area, {str(area)} mÂ²: the calculation will be adapted/optimized. Only for every meter a calculation will be done"
                self.dockwidget.textEdit_output.setText(f"{msg}")
                self.step = 100

        self.update_settings()

        # do alignment/prediction
        self._align()

        fcs = self.aligner.get_results_as_geojson(
            resulttype=AlignerResultType.PROCESSRESULTS, formula=self.formula
        )

        geojson_to_layer(
            self.LAYER_RESULT_DIFF,
            fcs["result_diff"],
            QgsStyle.defaultStyle().symbol("hashed black X"),
            False,
            self.GROUP_LAYER,
            self.tempfolder,
        )
        geojson_to_layer(
            self.LAYER_RESULT_DIFF_PLUS,
            fcs["result_diff_plus"],
            QgsStyle.defaultStyle().symbol("hashed cgreen /"),
            True,
            self.GROUP_LAYER,
            self.tempfolder,
        )
        geojson_to_layer(
            self.LAYER_RESULT_DIFF_MIN,
            fcs["result_diff_min"],
            QgsStyle.defaultStyle().symbol("hashed cred /"),
            True,
            self.GROUP_LAYER,
            self.tempfolder,
        )
        geojson_to_layer(
            self.LAYER_RESULT,
            fcs["result"],
            QgsStyle.defaultStyle().symbol("outline green"),
            True,
            self.GROUP_LAYER,
            self.tempfolder,
        )

        # set list with predicted values
        self.dockwidget.listWidget_predictions.clear()
        # TODO, loop over predictions en voeg toe met boodschap
        items = []
        items_with_name = []
        best_index = 0
        best_score = 0
        list_predictions = [k for k in (self.dict_evaluated_predictions[key]).keys()]
        print(str(list_predictions))
        for k in list_predictions:
            print(str(k))
            items.append(str(k))
            score = self.props_dict_evaluated_predictions[key][k][PREDICTION_SCORE]
            evaluation = self.props_dict_evaluated_predictions[key][k][
                EVALUATION_FIELD_NAME
            ]
            items_with_name.append(f"{str(k)}: {str(evaluation)} (score: {str(score)})")
            if score > best_score:
                best_score = score
                best_index = list_predictions.index(k)
                print("best index: " + str(best_index))
        self.dockwidget.listWidget_predictions.setFocus()
        self.dockwidget.listWidget_predictions.addItems(items_with_name)
        if len(items) > 0:
            self.dockwidget.listWidget_predictions.setCurrentRow(best_index)
            print ("best-index: "+str(items[best_index]))
            self.dockwidget.doubleSpinBox.setValue(round(float(items[best_index]), self.DECIMAL))
        else:
            self.dockwidget.textEdit_output.setText("No predictions")

    def onListItemActivated(self, currentItem):
        print("onListItemActivated")
        self.dockwidget.deactivateSelectTool()
        self._listItemActivated(currentItem)

    def _listItemActivated(self, currentItem):

        if currentItem is None:
            print("currentitem zero")
            return
        print("item activated with rd: " + currentItem.text())
        value = currentItem.text()
        value = value.split(":")[0]
        value = round(float(value), self.DECIMAL)
        print("item activated with rd - value: " + str(value))
        self.dockwidget.doubleSpinBox.setValue(value)
        index = self.relevant_distances.index(value)
        self.dockwidget.horizontalSlider.setValue(index)
        return

    def onSliderChange(self, index):
        print("onSliderChange: index -> " + str(index))
        value = self.relevant_distances[index]
        value = round(value, self.DECIMAL)
        self.dockwidget.doubleSpinBox.setValue(value)
        return

    def onSpinboxChange(self, value):
        value = round(value, self.DECIMAL)
        index = self.relevant_distances.index(value)
        self.dockwidget.horizontalSlider.setValue(index)
        print("onSpinboxChange: value -> " + str(value))

        # self.change_geometry()
        # Filter layers based on relevant distance
        get_layer_by_name(self.LAYER_RESULT).setSubsetString(
            f"brdr_relevant_distance = {value}"
        )
        get_layer_by_name(self.LAYER_RESULT_DIFF).setSubsetString(
            f"brdr_relevant_distance = {value}"
        )
        get_layer_by_name(self.LAYER_RESULT_DIFF_MIN).setSubsetString(
            f"brdr_relevant_distance = {value}"
        )
        get_layer_by_name(self.LAYER_RESULT_DIFF_PLUS).setSubsetString(
            f"brdr_relevant_distance = {value}"
        )
        self.get_wkt()
        return



    def onFeaturesIdentified(self,identified_features):
        """Code called when the feature is selected by the user"""
        self.listed_features = identified_features
        self.listFeatures()

    def get_graphic(self):
        feat = self.feature
        if feat is None:
            return
        key = feat.id()
        plot_series(self.relevant_distances, {key: self.diffs_dict[key]})
        return

    def get_visualisation(self):
        feat = self.feature
        if feat is None:
            return
        key = feat.id()
        show_map(
            {key: self.dict_evaluated_predictions[key]},
            {key: self.aligner.dict_thematic[key]},
            self.aligner.dict_reference,
        )
        return

    def change_geometry(self):
        feat = self.feature
        if feat is None:
            return
        key = feat.id()
        relevant_distance = round(self.dockwidget.doubleSpinBox.value(),self.DECIMAL)
        if relevant_distance in self.dict_processresults[key]:
            result = self.dict_processresults[key][relevant_distance]
            resulting_geom = result["result"]
        else:
            errormesssage = "Relevant_distance_result not calculated for: " + str(
                relevant_distance
            )
            print(errormesssage)
            return
        layer = self.layer
        layer.startEditing()
        qgis_geom = geom_shapely_to_qgis(resulting_geom)
        layer.changeGeometry(feat.id(), qgis_geom)
        layer.commitChanges()
        self.iface.messageBar().pushMessage("geometrie aangepast")

    def reset_geometry(self):
        feat = self.feature
        if feat is None:
            return
        layer = self.layer
        layer.startEditing()
        layer.changeGeometry(feat.id(), self.original_geometry)
        layer.commitChanges()
        self.iface.messageBar().pushMessage("geometrie gereset")

    def get_wkt(self):
        feat = self.feature
        if feat is None:
            return
        key = feat.id()
        print ("key:" + str(key))
        relevant_distance = round(self.dockwidget.doubleSpinBox.value(),self.DECIMAL)
        print (str(relevant_distance))
        if key is None or self.dict_processresults is None or not key in self.dict_processresults.keys():
            msg = f"No prediction-WKT of feature {str(key)}..."
            self.dockwidget.textEdit_output.setText(msg)
            return


        elif relevant_distance in self.dict_processresults[key]:
            result = self.dict_processresults[key][relevant_distance]
            resulting_geom = result["result"]
        else:
            errormesssage = "Relevant_distance_result not calculated for key : " + str(
                key
            )+ " at relevant distance-" + str(
                relevant_distance
            )

            self.dockwidget.textEdit_output.setText(errormesssage)
            return
        wkt = resulting_geom.wkt
        self.dockwidget.textEdit_output.setText(wkt)

    def _align(self):
        feat = self.feature
        selectedFeatures = []
        if feat is not None:
            selectedFeatures.append(feat)
        if len(selectedFeatures) == 0:
            self.dockwidget.textEdit_output.setText(
                "Geen features geselecteerd. Gelieve een feature te selecteren uit de actieve laag"
            )
            return

        dict_to_load = {}

        self.dockwidget.progressBar.setValue(0)
        for feature in selectedFeatures:
            feature_geom = feature.geometry()
            wkt = feature_geom.asWkt()
            geom_shapely = from_wkt(wkt)
            dict_to_load[feature.id()] = geom_shapely

        # Load thematic data
        self.aligner.load_thematic_data(DictLoader(dict_to_load))
        self.dockwidget.progressBar.setValue(25)
        # Load reference data for the on-the fly reference versions
        print(self.reference_choice)
        if self.reference_choice in GRB_TYPES:
            self.aligner.load_reference_data(
                GRBActualLoader(
                    grb_type=GRBType[self.reference_choice],
                    partition=1000,
                    aligner=self.aligner,
                )
            )
            print("grbtype")
        elif self.reference_choice in ADPF_VERSIONS:
            year = self.reference_choice.removeprefix("Adpf")
            self.aligner.load_reference_data(
                GRBFiscalParcelLoader(year=year, aligner=self.aligner, partition=1000)
            )
            print("adpftype")
        else:
            print("localtype")
            # Load reference into a shapely_dict:
            dict_reference = {}
            processing.run(
                "native:selectwithindistance",
                {
                    "INPUT": self.reference_layer,
                    "REFERENCE": self.layer,
                    "DISTANCE": 2 * self.maximum / 100,
                    "METHOD": 0,
                },
            )
            features = self.reference_layer.selectedFeatures()
            for current, feature in enumerate(features):
                id_reference = feature.attribute(self.reference_id)
                dict_reference[id_reference] = geom_qgis_to_shapely(feature.geometry())
            self.reference_layer.removeSelection()
            self.aligner.load_reference_data(DictLoader(dict_reference))
            self.aligner.name_reference_id = self.reference_id
            self.aligner.dict_reference_source["source"] = "local"
            self.aligner.dict_reference_source["version_date"] = "unknown"
        self.dockwidget.progressBar.setValue(50)

        dict_evaluated, props_dict_evaluated_predictions = self.aligner.evaluate(
            ids_to_evaluate=None,
            base_formula_field=None,
            all_predictions=True,
            relevant_distances=self.relevant_distances,
            prefer_full=self.full_parcel,
        )

        self.dict_processresults = self.aligner.dict_processresults
        self.dict_evaluated_predictions = dict_evaluated
        self.props_dict_evaluated_predictions = props_dict_evaluated_predictions
        self.diffs_dict = diffs_from_dict_processresults(
            self.dict_processresults, self.aligner.dict_thematic
        )

        outputMessage = "Voorspelde relevante afstanden: " + str(
            [str(k) for k in self.dict_evaluated_predictions[feat.id()].keys()]
        )
        self.dockwidget.textEdit_output.setText(outputMessage)
        return (
            self.dict_processresults,
            self.dict_evaluated_predictions,
            self.diffs_dict,
        )





