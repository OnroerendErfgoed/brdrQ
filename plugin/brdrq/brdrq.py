# -*- coding: utf-8 -*-

"""
/***************************************************************************
 BrdrQ
                                 A QGIS plugin
 brdrQ, a QGIS-plugin for aligning thematic borders to reference borders.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-10-11
        copyright            : (C) 2024 by Karel Dieussaert / Onroerend Erfgoed
        email                : karel.dieussaert@vlaanderen.be
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Karel Dieussaert / Onroerend Erfgoed'
__date__ = '2024-10-11'
__copyright__ = '(C) 2024 by Karel Dieussaert / Onroerend Erfgoed'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

import inspect
import os
import sys
from datetime import datetime

import numpy as np
from PyQt5.QtGui import QIcon
from PyQt5.QtWidgets import QAction, QListWidgetItem
from qgis.PyQt.QtCore import QCoreApplication
from qgis.PyQt.QtCore import Qt
from qgis.core import QgsApplication
from qgis.core import QgsProject
from qgis.core import QgsStyle
from shapely.io import from_wkt

from .brdrq_dockwidget import brdrQDockWidget
from .brdrq_help import brdrQHelp
from .brdrq_provider import BrdrQProvider
from .brdrq_settings import brdrQSettings
from .brdrq_utils import plot_series, show_map, geom_shapely_to_qgis, ENUM_REFERENCE_OPTIONS, \
    LOCAL_REFERENCE_LAYER, geojson_to_layer, ADPF_VERSIONS, geom_qgis_to_shapely, GRB_TYPES, get_layer_by_name

cmd_folder = os.path.split(inspect.getfile(inspect.currentframe()))[0]

if cmd_folder not in sys.path:
    sys.path.insert(0, cmd_folder)

from brdr.aligner import Aligner
from brdr.grb import GRBActualLoader, GRBFiscalParcelLoader
from brdr.enums import GRBType, AlignerResultType, OpenbaarDomeinStrategy
from brdr.loader import DictLoader


class BrdrQPlugin(object):

    def __init__(self, iface):
        self.provider = None
        self.iface = iface
        self.dockwidget = None
        self.pluginIsActive = False
        self.actions = []
        self.toolbar = self.iface.addToolBar('brdrQ')
        self.toolbar.setObjectName('brdrQ')
        self.minimum = 0
        self.maximum = 1000
        self.step = 10
        self.relevant_distances = None
        self.max_feature_count = 5000
        self.layer = None
        self.selected_features = None
        self.feature = None
        self.dict_series = None
        self.dict_predictions = None
        self.diffs_dict = None
        self.aligner = Aligner()
        self.od_strategy = None
        self.threshold_overlap_percentage = None
        self.reference_choice = None
        self.reference_layer = None
        self.reference_id = None
        self.reference_loader = None
        self.original_geometry = None
        self.GROUP_LAYER = "brdrQ_plugin"
        self.TEMPFOLDER = "brdrQ"
        self.LAYER_RESULT = "RESULT"  # parameter that holds the TOC layername of the result
        self.LAYER_RESULT_DIFF = "DIFF"  # parameter that holds the TOC layername of the resulting diff
        self.LAYER_RESULT_DIFF_PLUS = "DIFF_PLUS"  # parameter that holds the TOC layername of the resulting diff_plus
        self.LAYER_RESULT_DIFF_MIN = "DIFF_MIN"  # parameter that holds the TOC layername of the resulting diff_min
        self.helpDialog = brdrQHelp()
        self.settingsDialog = brdrQSettings()
        self.tempfolder = os.path.join("brdrQ", datetime.now().strftime("%Y%m%d%H%M%S"))

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('brdrQ', message)

    def initProcessing(self):
        """Init Processing provider for QGIS >= 3.8."""

        self.provider = BrdrQProvider()
        QgsApplication.processingRegistry().addProvider(self.provider)

    def initGui(self):
        self.initProcessing()
        icon = os.path.join(os.path.join(cmd_folder, 'icon.png'))
        action = QAction(QIcon(icon), 'brdrQ - GRB actual Parcel Aligner', self.iface.mainWindow())
        action.triggered.connect(self.openDock)
        # self.iface.addToolBarIcon(action)
        self.iface.addPluginToMenu("brdQ", action)
        self.toolbar.addAction(action)
        self.actions.append(action)
        # show the dockwidget
        # self.openDock()
        self.load_settings()

    def load_settings(self):
        for r in ENUM_REFERENCE_OPTIONS:
            self.settingsDialog.comboBox_referencelayer.addItem(r)
        for od in OpenbaarDomeinStrategy:
            self.settingsDialog.comboBox_odstrategy.addItem(od.name)

        self.settingsDialog.spinBox_threshold.setValue(50)
        self.settingsDialog.comboBox_referencelayer.currentIndexChanged.connect(self.update_reference_choice)
        self.settingsDialog.mMapLayerComboBox_reference.layerChanged.connect(self.updateFields_reference)
        self.settingsDialog.buttonBox_settings.accepted.connect(self.push_settings_ok)

        #Set initial settings
        self.settingsDialog.comboBox_referencelayer.setCurrentIndex(1)
        self.settingsDialog.comboBox_odstrategy.setCurrentIndex(5)
        self.settingsDialog.spinBox_threshold.setValue(50)
        self.settingsDialog.spinBox_max_relevant_distance.setValue(5)

        #Load initial settings into tool (same as pushing OK in settings Dialog)
        self._update_settings()
        return

    def update_reference_choice(self, index):
        print(str(index))
        if index == 0:
            self.settingsDialog.mMapLayerComboBox_reference.setEnabled(True)
            self.settingsDialog.mFieldComboBox_reference.setEnabled(True)
        else:
            self.settingsDialog.mMapLayerComboBox_reference.setEnabled(False)
            self.settingsDialog.mFieldComboBox_reference.setEnabled(False)
        return

    def updateFields_reference(self):
        layer = self.settingsDialog.mMapLayerComboBox_reference.currentLayer()
        self.settingsDialog.mFieldComboBox_reference.setLayer(layer)

    def push_settings_ok(self):
        self._update_settings()
        #self.dockwidget.listWidget_features.clear()
        self.dockwidget.listWidget_predictions.clear()
        self.dockwidget.textEdit_output.setText("Please select a feature to align")
        self.dockwidget.doubleSpinBox.setMaximum(self.maximum/100)
        self.dockwidget.horizontalSlider.setMaximum(self.maximum)

    def _update_settings(self):
        self.maximum = self.settingsDialog.spinBox_max_relevant_distance.value()*100
        self.relevant_distances = [round(k,1) for k in np.arange(self.minimum, self.maximum + self.step, self.step, dtype=int) / 100]
        self.od_strategy = OpenbaarDomeinStrategy[self.settingsDialog.comboBox_odstrategy.currentText()]
        print (self.od_strategy)
        self.threshold_overlap_percentage = self.settingsDialog.spinBox_threshold.value()
        self.reference_choice = self.settingsDialog.comboBox_referencelayer.currentText()
        self.reference_layer = None
        self.reference_id = None
        self.aligner = Aligner(od_strategy=self.od_strategy,
                               threshold_overlap_percentage=self.threshold_overlap_percentage)
        if self.reference_choice == LOCAL_REFERENCE_LAYER:

            self.reference_layer = self.settingsDialog.mMapLayerComboBox_reference.currentLayer()
            self.reference_id = self.settingsDialog.mFieldComboBox_reference.currentField()

            # Load reference into a shapely_dict:
            dict_reference = {}
            features = self.reference_layer.getFeatures()
            for current, feature in enumerate(features):
                id_reference = feature.attribute(self.reference_id)
                dict_reference[id_reference] = geom_qgis_to_shapely(
                    feature.geometry()
                )
            self.aligner.load_reference_data(DictLoader(dict_reference))
            self.aligner.name_reference_id = self.reference_id
            self.aligner.dict_reference_source["source"] = "local"
            self.aligner.dict_reference_source["version_date"] = "unknown"


        print(
            f"settings updated: Reference choice={self.reference_choice} - od_strategy={self.od_strategy} - threshold overlap percenatge = {str(self.threshold_overlap_percentage)}")
        return

    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""
        pass
        # print "** CLOSING brdrQ"
        tree = QgsProject.instance().layerTreeRoot()
        node_object = tree.findGroup(self.GROUP_LAYER)
        tree.removeChildNode(node_object)

        # disconnects
        self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)

        # remove this statement if dockwidget is to remain
        # for reuse if plugin is reopened
        # Commented next statement since it causes QGIS crashe
        # when closing the docked window:
        # self.dockwidget = None

        self.pluginIsActive = False

    def unload(self):
        QgsApplication.processingRegistry().removeProvider(self.provider)
        for action in self.actions:
            self.iface.removeToolBarIcon(action)
            self.toolbar.removeAction(action)
            self.iface.removePluginMenu("brdQ", action)
            del action
        # remove the toolbar
        del self.toolbar

    def openDock(self):
        if not self.pluginIsActive:
            self.pluginIsActive = True

            # print "** STARTING brdrQ"

            # dockwidget may not exist if:
            #    first run of plugin
            #    removed on close (see self.onClosePlugin method)
            if self.dockwidget == None:
                # Create the dockwidget (after translation) and keep reference
                self.dockwidget = brdrQDockWidget()

            self.dockwidget.horizontalSlider.setMinimum(self.minimum)
            self.dockwidget.horizontalSlider.setMaximum(self.maximum)
            self.dockwidget.horizontalSlider.setSingleStep(self.step)
            self.dockwidget.doubleSpinBox.setMinimum(self.minimum / 100)
            self.dockwidget.doubleSpinBox.setMaximum(self.maximum / 100)
            self.dockwidget.doubleSpinBox.setSingleStep(self.step / 100)
            self.dockwidget.doubleSpinBox.setDecimals(1)
            # connect to provide cleanup on closing of dockwidget
            self.dockwidget.closingPlugin.connect(self.onClosePlugin)
            self.dockwidget.pushButton_help.clicked.connect(self.show_help_dialog)
            self.dockwidget.pushButton_settings.clicked.connect(self.show_settings_dialog)
            self.dockwidget.pushButton_grafiek.clicked.connect(self.get_graphic)
            self.dockwidget.pushButton_visualisatie.clicked.connect(self.get_visualisation)
            self.dockwidget.pushButton_save.clicked.connect(self.change_geometry)
            self.dockwidget.pushButton_reset.clicked.connect(self.reset_geometry)
            # self.dockwidget.pushButton_select.clicked.connect(self.start_line_edit)
            self.dockwidget.pushButton_wkt.clicked.connect(self.get_wkt)
            self.dockwidget.mMapLayerComboBox.layerChanged.connect(self.setFeatures)
            self.dockwidget.listWidget_features.itemPressed.connect(self.onFeatureActivated)
            self.dockwidget.listWidget_predictions.itemPressed.connect(self.onListItemActivated)
            self.dockwidget.horizontalSlider.sliderMoved.connect(self.onSliderChange)
            self.dockwidget.doubleSpinBox.valueChanged.connect(self.onSpinboxChange)

            # show the dockwidget
            # TODO: fix to allow choice of dock location
            self.iface.addDockWidget(Qt.RightDockWidgetArea, self.dockwidget)
            # self.dockwidget.show()
            self.layer = self.dockwidget.mMapLayerComboBox.currentLayer()

    def show_help_dialog(self):
        self.helpDialog.show()

    def show_settings_dialog(self):
        self.settingsDialog.show()

    # def setIds(self):
    #     picker = self.dockwidget.mFeaturePickerWidget
    #     layer = self.dockwidget.mMapLayerComboBox.currentLayer()
    #     picker.setLayer(layer)
    #     picker.setDisplayExpression('$id')  # show ids in combobox

    def setFeatures(self):
        self.layer = self.dockwidget.mMapLayerComboBox.currentLayer()
        if self.layer is None:
            self.dockwidget.textEdit_output.setText("Please select a layer")
            return
        if self.layer.selectedFeatureCount() > self.max_feature_count or (
                self.layer.selectedFeatureCount() == 0 and self.layer.featureCount() > self.max_feature_count):
            self.dockwidget.textEdit_output.setText(
                f"Nr of features bigger than {str(self.max_feature_count)}. Please make a smaller selection of features")
            return
        self.selected_features = [f for f in self.layer.getSelectedFeatures()]
        if self.layer.selectedFeatureCount() == 0:
            self.selected_features = [f for f in self.layer.getFeatures()]
            self.dockwidget.textEdit_output.setText("No selected features in this layer, all features returned")

        # Clear the list widget
        self.dockwidget.listWidget_features.clear()

        # Add the selected features to the list widget
        for feature in self.selected_features:
            attributes = feature.attributes()
            attribute_string = ", ".join(str(attribute) for attribute in attributes)
            item = QListWidgetItem(f"ID: *{feature.id()}*, Attributes: {attribute_string}")
            self.dockwidget.listWidget_features.addItem(item)
        self.dockwidget.textEdit_output.setText(f"#Features: {str(len(self.selected_features))}")
        return

    def onFeatureActivated(self, currentItem):
        self._onFeatureChange(currentItem)

    def _onFeatureChange(self, currentItem):
        print("_onFeatureChange")
        self.feature = None
        if currentItem is None:
            print("currentItem is none")
            return
        feature_id = currentItem.text().split('*')[1]
        #print(f"Feature_id is {feature_id}")
        for feat in self.selected_features:
            #print(str(feat.id()))
            if str(feat.id()) == feature_id:
                #print("equal - >break")
                self.feature = feat
                break
        #print(self.feature)
        if self.feature is None:
            self.dockwidget.textEdit_output.setText(f"No feature found with ID {feature_id}")
            return

        # zoom to feature
        self.original_geometry = self.feature.geometry()
        box = self.feature.geometry().boundingBox()
        self.iface.mapCanvas().setExtent(box)
        self.iface.mapCanvas().refresh()
        key = self.feature.id()

        # do alignment/prediction
        self._align()

        fcs = self.aligner.get_results_as_geojson(resulttype=AlignerResultType.PROCESSRESULTS)

        geojson_to_layer(self.LAYER_RESULT_DIFF, fcs["result_diff"],
                         QgsStyle.defaultStyle().symbol("hashed black X"),
                         False, self.GROUP_LAYER, self.tempfolder)
        geojson_to_layer(self.LAYER_RESULT_DIFF_PLUS, fcs["result_diff_plus"],
                         QgsStyle.defaultStyle().symbol("hashed cgreen /"),
                         True, self.GROUP_LAYER, self.tempfolder)
        geojson_to_layer(self.LAYER_RESULT_DIFF_MIN, fcs["result_diff_min"],
                         QgsStyle.defaultStyle().symbol("hashed cred /"),
                         True, self.GROUP_LAYER, self.tempfolder)
        geojson_to_layer(self.LAYER_RESULT, fcs["result"],
                         QgsStyle.defaultStyle().symbol("outline green"),
                         True, self.GROUP_LAYER, self.tempfolder)

        # set list with predicted values
        self.dockwidget.listWidget_predictions.clear()
        items = [str(k) for k in self.dict_predictions[key]]
        self.dockwidget.listWidget_predictions.addItems(items)
        if len(items) > 1:
            self.dockwidget.listWidget_predictions.setCurrentRow(1)
            self.dockwidget.doubleSpinBox.setValue(round(float(items[1]), 1))
        elif len(items) > 0:
            self.dockwidget.listWidget_predictions.setCurrentRow(0)
            self.dockwidget.doubleSpinBox.setValue(round(float(items[0]), 1))
        else:
            self.dockwidget.textEdit_output.setText("No predictions")

    def onListItemActivated(self, currentItem):
        print("onListItemActivated")
        self._listItemActivated(currentItem)

    def _listItemActivated(self, currentItem):

        if currentItem is None:
            print ("currentitem zero")
            return
        print("item activated with rd: " + currentItem.text())
        value = round(float(currentItem.text()), 1)
        print ("item activated with rd - value: " + str(value))
        self.dockwidget.doubleSpinBox.setValue(value)
        self.dockwidget.horizontalSlider.setValue(int(100 * value))
        return

    def onSliderChange(self, value):
        print("onSliderChange: value -> " + str(value))
        value = round(value/100,1)
        self.dockwidget.doubleSpinBox.setValue(value)
        return

    def onSpinboxChange(self, value):
        value = round(value,1)
        self.dockwidget.horizontalSlider.setValue(int(value * 100))
        print ("onSpinboxChange: value -> " + str(value))

        # self.change_geometry()
        # Filter layers based on relevant distance
        get_layer_by_name(self.LAYER_RESULT).setSubsetString(f"brdr_relevant_distance = {value}")
        get_layer_by_name(self.LAYER_RESULT_DIFF).setSubsetString(f"brdr_relevant_distance = {value}")
        get_layer_by_name(self.LAYER_RESULT_DIFF_MIN).setSubsetString(f"brdr_relevant_distance = {value}")
        get_layer_by_name(self.LAYER_RESULT_DIFF_PLUS).setSubsetString(f"brdr_relevant_distance = {value}")
        return

    # def start_line_edit(self):
    #     print("button pushed")
    #     self.t = selectTool(self.iface, self.dockwidget.mMapLayerComboBox.currentLayer())
    #     self.iface.mapCanvas().setMapTool(self.t)

    def get_graphic(self):
        # feat = self.dockwidget.mFeaturePickerWidget.feature()
        feat = self.feature
        if feat is None:
            return
        key = feat.id()
        plot_series(self.relevant_distances, {key: self.diffs_dict[key]})
        return

    def get_visualisation(self):
        # feat = self.dockwidget.mFeaturePickerWidget.feature()
        feat = self.feature
        if feat is None:
            return
        key = feat.id()
        show_map(
            {key: self.dict_predictions[key]},
            {key: self.aligner.dict_thematic[key]},
            self.aligner.dict_reference,
        )
        return

    def change_geometry(self):
        # feat = self.dockwidget.mFeaturePickerWidget.feature()
        feat = self.feature
        if feat is None:
            return
        key = feat.id()
        relevant_distance = self.dockwidget.doubleSpinBox.value()
        if relevant_distance in self.dict_series[key]:
            result = self.dict_series[key][relevant_distance]
            resulting_geom = result['result']
        else:
            errormesssage = "Relevant_distance_result not calculated for: " + str(relevant_distance)
            self.iface.messageBar().pushMessage(errormesssage)
            print(errormesssage)
            return
        # layer = self.dockwidget.mMapLayerComboBox.currentLayer()
        layer = self.layer
        layer.startEditing()
        qgis_geom = geom_shapely_to_qgis(resulting_geom)
        layer.changeGeometry(feat.id(), qgis_geom)
        layer.commitChanges()
        self.iface.messageBar().pushMessage("geometrie aangepast")

    def reset_geometry(self):
        # feat = self.dockwidget.mFeaturePickerWidget.feature()
        feat = self.feature
        if feat is None:
            return
        # layer = self.dockwidget.mMapLayerComboBox.currentLayer()
        layer = self.layer
        layer.startEditing()
        layer.changeGeometry(feat.id(), self.original_geometry)
        layer.commitChanges()
        self.iface.messageBar().pushMessage("geometrie gereset")

    def get_wkt(self):
        # feat = self.dockwidget.mFeaturePickerWidget.feature()
        feat = self.feature
        if feat is None:
            return
        key = feat.id()
        relevant_distance = self.dockwidget.doubleSpinBox.value()
        if relevant_distance in self.dict_series[key]:
            result = self.dict_series[key][relevant_distance]
            resulting_geom = result['result']
        else:
            errormesssage = "Relevant_distance_result not calculated for: " + str(relevant_distance)
            self.iface.messageBar().pushMessage(errormesssage)
            self.dockwidget.textEdit_output.setText(errormesssage)
            return
        wkt = resulting_geom.wkt
        self.dockwidget.textEdit_output.setText(wkt)

    def _align(self):
        # feat = self.dockwidget.mFeaturePickerWidget.feature()
        feat = self.feature
        selectedFeatures = []
        if feat is not None:
            selectedFeatures.append(feat)
        if len(selectedFeatures) == 0:
            self.dockwidget.textEdit_output.setText(
                "Geen features geselecteerd. Gelieve een feature te selecteren uit de actieve laag")
            return
        # take selected feature(s)
        # run brdr (to actual GRB) for this feature
        # if self.reference_choice != LOCAL_REFERENCE_LAYER:
        #     self.aligner = Aligner(od_strategy=self.od_strategy,
        #                            threshold_overlap_percentage=self.threshold_overlap_percentage)

        dict_to_load = {}

        for feature in selectedFeatures:
            feature_geom = feature.geometry()
            wkt = feature_geom.asWkt()
            geom_shapely = from_wkt(wkt)
            dict_to_load[feature.id()] = geom_shapely
        # Load thematic data
        self.aligner.load_thematic_data(DictLoader(dict_to_load))
        # Load reference data for the on-the fly reference versions
        print (self.reference_choice)
        if self.reference_choice in GRB_TYPES:
            self.aligner.load_reference_data(
                GRBActualLoader(grb_type=GRBType[self.reference_choice], partition=1000, aligner=self.aligner))
            print ("grbtype")
        elif self.reference_choice in ADPF_VERSIONS:
            year = self.reference_choice.removeprefix("Adpf")
            self.aligner.load_reference_data(GRBFiscalParcelLoader(year=year, aligner=self.aligner, partition=1000))
            print("adpftype")
        else:
            print("localtype")
            pass

        self.dict_series, self.dict_predictions, self.diffs_dict = self.aligner.predictor(
            relevant_distances=self.relevant_distances)
        outputMessage = "Voorspelde relevante afstanden: " + str(
            [str(k) for k in self.dict_predictions[feat.id()].keys()])

        self.dockwidget.textEdit_output.setText(outputMessage)
        self.iface.messageBar().pushMessage(outputMessage)
        return self.dict_series, self.dict_predictions, self.diffs_dict

# from qgis.gui import QgsMapToolIdentifyFeature, QgsMapToolIdentify
# from qgis.core import (
#     Qgis, QgsVectorLayer
# )
# class selectTool(QgsMapToolIdentifyFeature):
#
#     def __init__(self, iface, layer):
#         self.iface = iface
#         self.canvas = self.iface.mapCanvas()
#         self.layer = layer
#         QgsMapToolIdentifyFeature.__init__(self, self.canvas, self.layer)
#         self.iface.currentLayerChanged.connect(self.active_changed)
#
#     def active_changed(self, layer):
#         self.layer.removeSelection()
#         if isinstance(layer, QgsVectorLayer) and layer.isSpatial():
#             self.layer = layer
#             self.setLayer(self.layer)
#
#     def canvasPressEvent(self, event):
#         found_features = self.identify(event.x(), event.y(), [self.layer], QgsMapToolIdentify.TopDownAll)
#         print(found_features)
#         self.layer.selectByIds([f.mFeature.id() for f in found_features], QgsVectorLayer.AddToSelection)
#
#     def deactivate(self):
#         self.layer.removeSelection()
